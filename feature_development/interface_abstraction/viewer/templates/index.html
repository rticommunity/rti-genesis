<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stunning Graph Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;500;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
       
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #0a0f1a 0%, #020408 100%);
            height: 100vh;
            width: 100vw;
            font-family: 'Inter', 'Orbitron', sans-serif;
        }
       
        #container {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
       
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.01);
            backdrop-filter: blur(40px) saturate(180%);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.02),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
       
        .control-button {
            position: relative;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            padding: 10px 18px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            user-select: none;
            letter-spacing: 0.5px;
            text-transform: none;
            min-width: 100px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-shrink: 0;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 2px rgba(0, 0, 0, 0.24),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .control-button:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow:
                0 12px 36px rgba(0, 0, 0, 0.2),
                0 1px 3px rgba(0,0,0,0.24),
                inset 0 1px 0 rgba(255,255,255,0.15),
                inset 0 -1px 0 rgba(0,0,0,0.1);
        }
       
        .control-button:active {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(0);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 2px rgba(0, 0, 0, 0.24),
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        .control-button > span:last-of-type {
            position: relative;
            z-index: 2;
        }
        .control-button > span:not(:last-of-type) {
            position: absolute;
            display: block;
            box-shadow: 0 0 15px rgba(128, 200, 255, 0.9), 0 0 30px rgba(128, 200, 255, 0.7);
        }
        .control-button > span:nth-child(1) {
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(1) {
            animation: animateBorder1 2s linear infinite;
        }
        .control-button > span:nth-child(2) {
            top: -100%;
            right: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(2) {
            animation: animateBorder2 2s linear infinite;
            animation-delay: 0.5s;
        }
        .control-button > span:nth-child(3) {
            bottom: 0;
            right: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(270deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(3) {
            animation: animateBorder3 2s linear infinite;
            animation-delay: 1s;
        }
        .control-button > span:nth-child(4) {
            bottom: -100%;
            left: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(0deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(4) {
            animation: animateBorder4 2s linear infinite;
            animation-delay: 1.5s;
        }
        @keyframes animateBorder1 { 0% { left: -100%; } 50%, 100% { left: 100%; } }
        @keyframes animateBorder2 { 0% { top: -100%; } 50%, 100% { top: 100%; } }
        @keyframes animateBorder3 { 0% { right: -100%; } 50%, 100% { right: 100%; } }
        @keyframes animateBorder4 { 0% { bottom: -100%; } 50%, 100% { bottom: 100%; } }
        .activate-button {
            background: linear-gradient(135deg,
                rgba(255, 100, 100, 0.15) 0%,
                rgba(255, 50, 50, 0.1) 100%);
            border: 1px solid rgba(255, 100, 100, 0.3);
            color: rgba(255, 150, 150, 0.95);
        }
       
        .activate-button:hover {
            background: linear-gradient(135deg,
                rgba(255, 120, 120, 0.2) 0%,
                rgba(255, 80, 80, 0.15) 100%);
            border-color: rgba(255, 150, 150, 0.4);
            color: rgba(255, 200, 200, 1);
        }
       
        .activate-button > span:not(:last-of-type) {
            box-shadow: 0 0 15px rgba(255, 120, 120, 0.9), 0 0 30px rgba(255, 120, 120, 0.7);
        }
        .activate-button > span:nth-child(1) { background: linear-gradient(90deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(2) { background: linear-gradient(180deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(3) { background: linear-gradient(270deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(4) { background: linear-gradient(0deg, transparent, rgba(255, 120, 120, 1)); }
       
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            line-height: 1.6;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px) saturate(150%);
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
       
        .stats div {
            margin-bottom: 4px;
            padding: 2px 0;
        }
       
        .stats div:last-child {
            margin-bottom: 0;
        }
       
        .control-button .icon {
            width: 16px;
            height: 16px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
       
        .control-button:hover .icon {
            opacity: 1;
        }
       
        .controls::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg,
                rgba(255, 255, 255, 0.05) 0%,
                transparent 25%,
                transparent 75%,
                rgba(255, 255, 255, 0.05) 100%);
            border-radius: 21px;
            z-index: -1;
            opacity: 0.5;
        }
        @media (max-width: 768px) {
             .controls {
                 gap: 8px;
                 bottom: 15px;
                 left: 15px;
                 right: 15px;
                 transform: translateX(0);
                 width: auto;
                 flex-direction: column;
             }
            .control-button {
                 padding: 10px 14px;
                 font-size: 11px;
                 flex-grow: 1;
                 width: 100%;
             }
            .stats {
                 top: 15px;
                 right: 15px;
                 padding: 8px 12px;
             }
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            cursor: pointer;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        .debug-panel {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 220px;
            overflow: auto;
            color: rgba(255, 255, 255, 0.85);
            font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.35);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            z-index: 6;
            padding: 8px 10px;
        }
        .debug-panel.hidden { display: none; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="stats" id="stats">
        <div>Active: 0</div>
        <div>Starts: 0</div>
        <div>Completes: 0</div>
        <div>Unmatched starts: 0</div>
    </div>
    <div class="controls">
        <button class="control-button" id="refresh">
            <span></span><span></span><span></span><span></span>
            <span>Refresh</span>
        </button>
        <button class="control-button" id="loadSnapshot">
            <span></span><span></span><span></span><span></span>
            <span>Load Snapshot</span>
        </button>
        <button class="control-button" id="edgeLabels">
            <span></span><span></span><span></span><span></span>
            <span>Edge Labels: Off</span>
        </button>
        <button class="control-button" id="debugLog">
            <span></span><span></span><span></span><span></span>
            <span>Debug Log</span>
        </button>
        <button class="control-button" id="layoutForce">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Force</span>
        </button>
        <button class="control-button" id="layoutLayered">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Layered</span>
        </button>
        <button class="control-button" id="layoutRadial">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Radial</span>
        </button>
        <label class="checkbox-label" for="disconnected">
            <input type="checkbox" id="disconnected" checked>
            Disconnected
        </label>
        <button class="control-button activate-button" id="activateTrigger">
            <span></span><span></span><span></span><span></span>
            <span>Activate Graph</span>
        </button>
        <button class="control-button" id="toggleTheme">
            <span></span><span></span><span></span><span></span>
            <span>Theme: Inferno</span>
        </button>
        <button class="control-button" id="morphButton">
            <span></span><span></span><span></span><span></span>
            <span>Morph Shape</span>
        </button>
    </div>
    <div id="debugPanel" class="debug-panel hidden"></div>
    <script id="nodeVertexShader" type="x-shader/x-vertex">
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        void main() {
            vPosition = position;
            vNormal = normal;
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="nodeFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 baseColor;
        uniform vec3 accentColor;
        uniform float energy;
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        float noise(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
        void main() {
            vec2 uv = vUv + time * 0.02;
            float n1 = noise(uv * 8.0);
            float n2 = noise(uv * 16.0);
            float pattern = n1 * 0.7 + n2 * 0.3;
            vec3 color = mix(baseColor, accentColor, pattern);
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.5);
            color += fresnel * accentColor * 0.5;
            color *= (1.0 + energy * 0.8);
            gl_FragColor = vec4(color, 1.0);
        }
    </script>
    <script id="edgeVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="edgeFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 color;
        uniform float opacity;
        uniform float energy;
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            float flow = abs(sin(vUv.x * 15.0 - time * 12.0));
            float pulse = sin(time * 8.0) * 0.5 + 0.5;
            float pattern = pow(flow, 1.5) * (1.0 + pulse * energy);
            float fade = sin(vUv.x * 3.14159);
            vec3 finalColor = color * (pattern * 2.0 + 0.3);
            float alpha = fade * opacity * (pattern + 0.2) * (1.0 + energy);
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.161.0/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/",
            "three-forcegraph": "https://esm.sh/three-forcegraph@1.43.0?external=three"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import ForceGraph3D from 'three-forcegraph';
        
        let scene, camera, renderer, composer, controls, clock;
        let graph, activeEffects = [];
        let currentThemeIndex = 0;
        let isMorphed = false;
        let currentLayout = 'force';
        let edgeLabelsVisible = false;
        // Controls spacing between nodes in force layout
        let linkDistanceMultiplier = 1.2; // 2x spread
        
        const container = document.getElementById('container');
        const statsDiv = document.getElementById('stats');
        const activateButton = document.getElementById('activateTrigger');
        const refreshButton = document.getElementById('refresh');
        const loadSnapshotButton = document.getElementById('loadSnapshot');
        const edgeLabelsButton = document.getElementById('edgeLabels');
        const debugLogButton = document.getElementById('debugLog');
        const layoutForceButton = document.getElementById('layoutForce');
        const layoutLayeredButton = document.getElementById('layoutLayered');
        const layoutRadialButton = document.getElementById('layoutRadial');
        const disconnectedCheckbox = document.getElementById('disconnected');
        const themeButton = document.getElementById('toggleTheme');
        const morphButton = document.getElementById('morphButton');
        const debugPanel = document.getElementById('debugPanel');
        
        const themes = [
            {
                name: 'Contrast',
                nodeColors: {
                    Interface: [0.20, 0.70, 1.00],   // blue
                    Agent:     [0.20, 1.00, 0.55],   // green
                    Service:    [1.00, 0.60, 0.20],   // orange
                    Function:   [0.90, 0.30, 0.95]    // magenta
                },
                accentColors: {
                    Interface: [0.60, 0.90, 1.00],
                    Agent:     [0.60, 1.00, 0.85],
                    Service:    [1.00, 0.85, 0.60],
                    Function:   [1.00, 0.60, 1.00]
                },
                edgeColor: 0xeef3ff,
                ambientLightColor: 0x0a1020,
                pointLightColor: 0xaad4ff,
                dirLight1: 0x44aaff,
                dirLight2: 0x44ff88
            },
            {
                name: 'Veridian',
                nodeColors: { Interface: [0.2, 0.8, 0.5], Agent: [0.1, 0.6, 0.7], Service: [0.5, 0.8, 0.2], Function: [0.3, 0.7, 0.4] },
                accentColors: { Interface: [0.8, 1.0, 0.9], Agent: [0.5, 0.9, 1.0], Service: [0.9, 1.0, 0.6], Function: [0.6, 0.9, 0.7] },
                edgeColor: 0xeeffee,
                ambientLightColor: 0x0a3024,
                pointLightColor: 0xccffdd,
                dirLight1: 0x33cc88,
                dirLight2: 0x4488cc
            },
            {
                name: 'Celestial',
                nodeColors: { Interface: [1.0, 0.4, 0.4], Agent: [0.3, 0.8, 0.3], Service: [0.3, 0.4, 1.0], Function: [0.5, 0.5, 1.0] },
                accentColors: { Interface: [1.0, 0.8, 0.2], Agent: [0.6, 1.0, 0.8], Service: [0.8, 0.6, 1.0], Function: [0.7, 0.7, 1.0] },
                edgeColor: 0xffeebb,
                ambientLightColor: 0x1a2440,
                pointLightColor: 0xffe4b5,
                dirLight1: 0x4488ff,
                dirLight2: 0x8844ff
            }
        ];
        
        // Graph data populated from server events/snapshot
        const graphData = {
            nodes: [],
            links: []
        };
        
        let filteredGraphData = {...graphData};
        let knownNodeIds = new Set();
        function idOf(val) {
            if (val && typeof val === 'object') return String(val.id ?? '');
            return String(val ?? '');
        }
        function getNodeMeta(id) {
            const s = String(id);
            const n = graphData.nodes.find(nd => String(nd.id) === s) || filteredGraphData.nodes.find(nd => String(nd.id) === s);
            return n ? { id: s, label: n.name || '', type: n.type || '' } : { id: s, label: '', type: '' };
        }
        function linkKeysForSource(src) {
            const s = String(src);
            return (filteredGraphData.links || [])
                .filter(l => idOf(l.source) === s)
                .map(l => `${idOf(l.source)}->${idOf(l.target)}`);
        }
        function linkKeysForTarget(tgt) {
            const t = String(tgt);
            return (filteredGraphData.links || [])
                .filter(l => idOf(l.target) === t)
                .map(l => `${idOf(l.source)}->${idOf(l.target)}`);
        }

        // Debug helpers
        const activeByCall = new Map();
        let totalStarts = 0, totalCompletes = 0;
        function appendDebugLine(text) {
            if (!debugPanel) return;
            const div = document.createElement('div');
            div.textContent = text;
            debugPanel.appendChild(div);
            while (debugPanel.childElementCount > 500) debugPanel.removeChild(debugPanel.firstElementChild);
            debugPanel.scrollTop = debugPanel.scrollHeight;
        }
        function setDebugVisible(visible) {
            if (!debugPanel) return;
            debugPanel.classList.toggle('hidden', !visible);
        }
        function updateMetrics() {
            let active = 0; activeByCall.forEach(v => { if (v > 0) active += v; });
            const unmatched = Array.from(activeByCall.values()).reduce((a,b)=> a + (b>0?b:0), 0);
            statsDiv.children[0].textContent = `Active: ${active}`;
            statsDiv.children[1].textContent = `Starts: ${totalStarts}`;
            statsDiv.children[2].textContent = `Completes: ${totalCompletes}`;
            statsDiv.children[3].textContent = `Unmatched starts: ${unmatched}`;
        }
        function mapTypeToThemeKey(t) {
            if (!t) return 'Function';
            const T = String(t).toUpperCase();
            if (T === 'INTERFACE') return 'Interface';
            if (T === 'SERVICE') return 'Service';
            if (T === 'FUNCTION') return 'Function';
            if (T === 'PRIMARY_AGENT' || T === 'AGENT_PRIMARY' || T === 'SPECIALIZED_AGENT' || T === 'AGENT') return 'Agent';
            return 'Function';
        }
        function elementsToGraphData(elements) {
            const nodes = [];
            const links = [];
            (elements?.nodes || []).forEach(n => {
                const d = n.data || {};
                const id = String(d.id || d.node_id || '');
                if (!id) return;
                nodes.push({ id, type: mapTypeToThemeKey(d.type), name: d.label || id });
            });
            (elements?.edges || []).forEach(e => {
                const d = e.data || {};
                const source = String(d.source || d.source_id || '');
                const target = String(d.target || d.target_id || '');
                if (!source || !target) return;
                links.push({ source, target });
            });
            return { nodes, links };
        }
        
        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(100, 80, 100);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            
            setupLighting();
            setupPostProcessing();
            createEnvironment();
            setupGraph();
            applyTheme(currentThemeIndex);
            setLayout(currentLayout);
            
            window.addEventListener('resize', onWindowResize);
            activateButton.addEventListener('click', activateGraph);
            refreshButton.addEventListener('click', refreshGraph);
            loadSnapshotButton.addEventListener('click', loadSnapshot);
            edgeLabelsButton.addEventListener('click', toggleEdgeLabels);
            debugLogButton.addEventListener('click', () => setDebugVisible(debugPanel.classList.contains('hidden')));
            layoutForceButton.addEventListener('click', () => setLayout('force'));
            layoutLayeredButton.addEventListener('click', () => setLayout('layered'));
            layoutRadialButton.addEventListener('click', () => setLayout('radial'));
            disconnectedCheckbox.addEventListener('change', toggleDisconnected);
            themeButton.addEventListener('click', toggleTheme);
            morphButton.addEventListener('click', toggleMorph);

            // Socket wiring
            let graphUpdateTimer = null;
            let graphNeedsUpdate = false;
            
            function scheduleGraphUpdate() {
                graphNeedsUpdate = true;
                if (graphUpdateTimer) return;
                graphUpdateTimer = setTimeout(() => {
                    graphUpdateTimer = null;
                    if (graphNeedsUpdate) {
                        graphNeedsUpdate = false;
                        updateGraphData();
                    }
                }, 50); // Batch updates within 50ms window
            }
            
            try {
                const ioUrl = `${window.location.protocol}//${window.location.host}`;
                const socket = window.io && window.io(ioUrl, { transports: ['websocket','polling'] });
                if (!socket) {
                    appendDebugLine('Socket.IO not available');
                } else {
                    socket.on('connect', () => { appendDebugLine('socket connected'); socket.emit('graph_snapshot'); });
                    socket.on('disconnect', () => { appendDebugLine('socket disconnected'); });
                    socket.on('graph_snapshot', (data) => {
                        try {
                            const nodes = data?.elements?.nodes?.length || 0;
                            const edges = data?.elements?.edges?.length || 0;
                            appendDebugLine(`graph_snapshot nodes=${nodes} edges=${edges}`);
                            const gd = elementsToGraphData(data.elements || {});
                            graphData.nodes = gd.nodes;
                            graphData.links = gd.links;
                            updateGraphData();
                        } catch (e) { console.error(e); appendDebugLine(`snapshot error: ${e}`); }
                    });
                    socket.on('node_update', (payload) => {
                        try {
                            const n = payload.node || payload || {};
                            const id = String(n.component_id || n.node_id || n.id || '');
                            if (!id) return;
                            const type = n.component_type || n.node_type;
                            const state = n.state || n.node_state;
                            const label = (n.attrs && (n.attrs.prefered_name || n.attrs.service_name || n.attrs.function_name)) || n.node_name || id;
                            let existing = graphData.nodes.find(nd => nd.id === id);
                            let wasNew = false;
                            if (!existing) {
                                graphData.nodes.push({ id, type: mapTypeToThemeKey(type), name: label });
                                appendDebugLine(`node_add id=${id} type=${type||''} label="${label||''}"`);
                                wasNew = true;
                                // Keep known set in sync even if we don't refresh immediately
                                knownNodeIds.add(id);
                            } else {
                                existing.name = label;
                                existing.type = mapTypeToThemeKey(type) || existing.type;
                                appendDebugLine(`node_update id=${id} type=${type||''} label="${label||''}"`);
                            }
                            // Don't update graph data on every node change - it clears linkObjects!
                            if (wasNew) {
                                scheduleGraphUpdate();
                            }
                        } catch (e) { /* ignore */ }
                    });
                    socket.on('edge_update', (payload) => {
                        try {
                            const e = payload.edge || payload || {};
                            const sid = String(e.source_id || e.source || '');
                            const tid = String(e.target_id || e.target || '');
                            const et = e.edge_type || e.type || '';
                            if (!sid || !tid) return;
                            if (!graphData.links.find(l => idOf(l.source) === sid && idOf(l.target) === tid)) {
                                graphData.links.push({ source: sid, target: tid });
                                appendDebugLine(`edge_add ${sid} -> ${tid} type=${et}`);
                                // Don't update graph data on every edge change - it clears linkObjects!
                                scheduleGraphUpdate();
                            }
                        } catch (e) { /* ignore */ }
                    });
                    socket.on('activity', (act) => {
                        try {
                            const sid = act.source_id || '';
                            const tid = act.target_id || '';
                            const ev = String(act.event_type || '');
                            const isStart = ev.endsWith('_START');
                            const isComplete = ev.endsWith('_COMPLETE') || ev.endsWith('RECEIVED');
                            const callId = act.call_id || `${sid}->${tid}:${ev}:${act.timestamp}`;
                            const agentId = act.primary_agent_id || '';
                            if (isStart) { totalStarts++; activeByCall.set(callId, (activeByCall.get(callId)||0) + 1); }
                            if (isComplete) { const cur = activeByCall.get(callId)||0; totalCompletes++; activeByCall.set(callId, Math.max(0, cur-1)); }
                            updateMetrics();
                            appendDebugLine(`activity ${ev} ${sid} -> ${tid} call=${String(callId).slice(0,8)}${agentId ? ` agent=${agentId}` : ''}`);
                            
                            // Special node glows for classification and LLM calls
                            if (ev === 'CLASSIFICATION_RESULT') {
                                // Glow the agent that did the classification
                                scene.traverse(obj => {
                                    if (obj.userData?.node?.id === sid && obj.material?.uniforms?.energy) {
                                        const originalEnergy = obj.material.uniforms.energy.value;
                                        obj.material.uniforms.energy.value = 2.0;
                                        setTimeout(() => {
                                            if (obj.material) obj.material.uniforms.energy.value = originalEnergy;
                                        }, 800);
                                    }
                                });
                            }
                            // Visual pulse: prefer link pulse; if unmatched in both directions, draw an arc between node positions
                            if (sid && tid) {
                                const color = (isComplete ? 0x2ecc71 : 0xe74c3c);
                                let ok = pulseLink(sid, tid, color);
                                
                                // Special handling for FUNCTION_CALL events
                                if (!ok && (ev === 'FUNCTION_CALL_START' || ev === 'FUNCTION_CALL_COMPLETE')) {
                                    const tgtNode = graphData.nodes.find(n => n.id === tid);
                                    
                                    // If target is a function, we need to find the right edges
                                    if (tgtNode && tgtNode.type === 'Function') {
                                        // Find service that owns this function
                                        const serviceEdge = filteredGraphData.links.find(l => 
                                            idOf(l.target) === tid && 
                                            graphData.nodes.find(n => n.id === idOf(l.source))?.type === 'Service'
                                        );
                                        if (serviceEdge) {
                                            const serviceId = idOf(serviceEdge.source);
                                            
                                            // If source is the service itself, pulse service->function
                                            if (sid === serviceId) {
                                                // Add a small delay if we just routed an agent->service call
                                                // This makes the sequence more visible
                                                const delay = ev === 'FUNCTION_CALL_START' ? 200 : 0;
                                                setTimeout(() => {
                                                    const success = pulseLink(sid, tid, color);
                                                    if (!success) appendDebugLine(`service->function pulse failed for ${sid}->${tid}`);
                                                }, delay);
                                                ok = true; // Consider it handled
                                            } else {
                                                // Otherwise, it's an agent calling - use primary_agent_id if available
                                                if (agentId && knownNodeIds.has(agentId)) {
                                                    ok = pulseLink(agentId, serviceId, color);
                                                    if (ok) appendDebugLine(`function_call_rerouted ${sid}->${tid} to agent->service ${agentId}->${serviceId}`);
                                                } else {
                                                    // Fallback: find which agent has access to this service
                                                    const agentToService = filteredGraphData.links.find(l =>
                                                        idOf(l.target) === serviceId &&
                                                        graphData.nodes.find(n => n.id === idOf(l.source))?.type === 'Agent'
                                                    );
                                                    if (agentToService) {
                                                        const foundAgentId = idOf(agentToService.source);
                                                        ok = pulseLink(foundAgentId, serviceId, color);
                                                        if (ok) appendDebugLine(`function_call_rerouted ${sid}->${tid} to agent->service ${foundAgentId}->${serviceId}`);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                if (!ok) {
                                    const a = getNodePositionById(sid);
                                    const b = getNodePositionById(tid);
                                    if (a && b) createArcPulseByPositions(a, b, color);
                                }
                            }
                        } catch (e) { /* ignore */ }
                    });
                }
            } catch (e) { appendDebugLine(`socket error: ${e}`); }
        }
        
        let ambientLight, pointLight, dirLight1, dirLight2;
        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0x1a2440, 0.8);
            scene.add(ambientLight);
            
            pointLight = new THREE.PointLight(0xffe4b5, 3, 500);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
            
            dirLight1 = new THREE.DirectionalLight(0x4488ff, 0.5);
            dirLight1.position.set(-200, 100, -100);
            scene.add(dirLight1);
            
            dirLight2 = new THREE.DirectionalLight(0x8844ff, 0.3);
            dirLight2.position.set(100, -50, 200);
            scene.add(dirLight2);
        }
        
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.1);
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());
        }
        
        function createEnvironment() {
            // Similar to example, add starfield layers
            const layers = [
                { count: 5000, distance: [200, 500], size: [0.5, 1.0], color: 0x6688bb },
                { count: 3000, distance: [500, 1000], size: [0.8, 1.5], color: 0x88aadd },
                { count: 2000, distance: [1000, 2000], size: [1.0, 2.0], color: 0xaaccff }
            ];
            layers.forEach(layer => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(layer.count * 3);
                const colors = new Float32Array(layer.count * 3);
                const sizes = new Float32Array(layer.count);
                const color = new THREE.Color(layer.color);
                for (let i = 0; i < layer.count; i++) {
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = layer.distance[0] + Math.random() * (layer.distance[1] - layer.distance[0]);
                    positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i*3+2] = r * Math.cos(phi);
                    colors[i*3] = color.r;
                    colors[i*3+1] = color.g;
                    colors[i*3+2] = color.b;
                    sizes[i] = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                const material = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.7
                });
                const starfield = new THREE.Points(geometry, material);
                scene.add(starfield);
            });
        }
        
        let nodeMaterials = {};
        let edgeMaterial;
        let linkObjects = new Map(); // key: "source->target" â†’ THREE.Group for the link
        let pendingLinkPulses = new Map(); // key -> [{ colorHex }]
        function setupGraph() {
            graph = new ForceGraph3D({
                extraRenderers: [] // If needed for custom
            });
            scene.add(graph);
            
            // Custom node object
            graph.nodeThreeObject(node => {
                const geo = new THREE.IcosahedronGeometry(5 + Math.random() * 5, 3); // Size based on something
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        baseColor: { value: new THREE.Vector3(...themes[currentThemeIndex].nodeColors[node.type]) },
                        accentColor: { value: new THREE.Vector3(...themes[currentThemeIndex].accentColors[node.type]) },
                        energy: { value: 0.0 }
                    },
                    vertexShader: document.getElementById('nodeVertexShader').textContent,
                    fragmentShader: document.getElementById('nodeFragmentShader').textContent
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.userData.node = node;
                mesh.userData.originalPositions = geo.attributes.position.clone();
                const targetPos = new Float32Array(geo.attributes.position.count * 3);
                for (let i = 0; i < geo.attributes.position.count; i++) {
                    const p = new THREE.Vector3().fromBufferAttribute(geo.attributes.position, i);
                    const cubeP = getCubePosition(p).multiplyScalar(5 + Math.random() * 5);
                    targetPos[i*3] = cubeP.x;
                    targetPos[i*3+1] = cubeP.y;
                    targetPos[i*3+2] = cubeP.z;
                }
                mesh.userData.targetPositions = new THREE.BufferAttribute(targetPos, 3);
                nodeMaterials[node.id] = mat;
                return mesh;
            });
            
            // Custom edge as tube with shader
            edgeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(themes[currentThemeIndex].edgeColor) },
                    opacity: { value: 0.02 },
                    energy: { value: 0.0 }
                },
                vertexShader: document.getElementById('edgeVertexShader').textContent,
                fragmentShader: document.getElementById('edgeFragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const edgeGeom = new THREE.CylinderGeometry(1, 1, 1, 8, 1, false);
            edgeGeom.rotateX(Math.PI / 2);
            graph.linkThreeObjectExtend(true)
                .linkThreeObject(link => {
                    const group = new THREE.Group();
                    const cylinder = new THREE.Mesh(edgeGeom.clone(), edgeMaterial.clone());
                    cylinder.name = 'edgeCylinder';
                    group.add(cylinder);
                    // Colored pulse overlay (thicker, hidden by default)
                    const pulseMat = edgeMaterial.clone();
                    pulseMat.uniforms.opacity.value = 0.0;
                    const pulse = new THREE.Mesh(edgeGeom.clone(), pulseMat);
                    pulse.name = 'edgePulse';
                    pulse.scale.set(1.2, 1.2, 1);
                    group.add(pulse);
                    const labelText = `${(link.source?.name || (link.source && link.source.id) || '')} -> ${(link.target?.name || (link.target && link.target.id) || '')}`;
                    const label = createTextSprite(labelText);
                    label.name = 'edgeLabel';
                    label.visible = edgeLabelsVisible;
                    label.position.set(0, 2, 0);
                    group.add(label);
                    // Track object for activations
                    const srcId = idOf(link.source);
                    const tgtId = idOf(link.target);
                    if (srcId && tgtId) {
                        const key = `${srcId}->${tgtId}`;
                        group.userData.linkKey = key;
                        linkObjects.set(key, group);
                        appendDebugLine(`link_object_stored key=${key}`);
                        // Apply any pending pulses queued before the link object existed
                        const pend = pendingLinkPulses.get(key);
                        if (pend && pend.length) {
                            pend.splice(0).forEach(p => {
                                appendDebugLine(`apply_pending_pulse ${key}`);
                                setTimeout(() => pulseLink(srcId, tgtId, p.colorHex), 0);
                            });
                            pendingLinkPulses.delete(key);
                        }
                    }
                    return group;
                })
                .linkPositionUpdate((obj, { start, end }) => {
                    const mid = new THREE.Vector3(
                        (start.x + end.x) / 2,
                        (start.y + end.y) / 2,
                        (start.z + end.z) / 2
                    );
                    obj.position.copy(mid);
                    obj.lookAt(new THREE.Vector3(end.x, end.y, end.z));
                    const cylinder = obj.getObjectByName('edgeCylinder');
                    const pulse = obj.getObjectByName('edgePulse');
                    if (cylinder || pulse) {
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        const dz = end.z - start.z;
                        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        if (cylinder) cylinder.scale.set(1, 1, distance);
                        if (pulse) pulse.scale.set(pulse.scale.x, pulse.scale.y, distance);
                    }
                    return true;
                });
            
            // Removed linkLabel (not available in three-forcegraph); labels handled via sprites
            
            updateGraphData();
        }

        // Increase spacing for force-directed layout
        function configureForceSpacing(mult = 3) {
            try {
                const linkForce = typeof graph.d3Force === 'function' ? graph.d3Force('link') : null;
                if (linkForce && typeof linkForce.distance === 'function') {
                    linkForce.distance(90 * mult); // base ~90, scaled up
                }
                const chargeForce = typeof graph.d3Force === 'function' ? graph.d3Force('charge') : null;
                if (chargeForce && typeof chargeForce.strength === 'function') {
                    chargeForce.strength(-60 * mult); // stronger repulsion to spread nodes
                }
                if (typeof graph.cooldownTicks === 'function') graph.cooldownTicks(200);
            } catch (e) {
                // force config not available on current layout
            }
        }
        
        function getCubePosition(p) {
            const v = p.clone().normalize();
            const max = Math.max(Math.abs(v.x), Math.abs(v.y), Math.abs(v.z));
            return v.divideScalar(max);
        }
        
        function createTextSprite(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 64;
            const padding = 16;
            ctx.font = `${fontSize}px Inter, Arial, sans-serif`;
            const metrics = ctx.measureText(text);
            canvas.width = Math.ceil(metrics.width + padding * 2);
            canvas.height = Math.ceil(fontSize + padding * 2);
            ctx.font = `${fontSize}px Inter, Arial, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.textBaseline = 'top';
            ctx.fillText(text, padding, padding);
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
            const sprite = new THREE.Sprite(material);
            const scaleFactor = 0.05;
            sprite.scale.set(canvas.width * scaleFactor, canvas.height * scaleFactor, 1);
            sprite.userData.isLinkLabel = true;
            return sprite;
        }
        
        function updateGraphData() {
            if (!disconnectedCheckbox.checked) {
                // Filter out disconnected nodes
                const connectedNodes = new Set();
                graphData.links.forEach(link => {
                    connectedNodes.add(link.source);
                    connectedNodes.add(link.target);
                });
                filteredGraphData.nodes = graphData.nodes.filter(node => connectedNodes.has(node.id));
                filteredGraphData.links = graphData.links;
            } else {
                filteredGraphData = {...graphData};
            }
            // Update known nodes immediately
            knownNodeIds = new Set(filteredGraphData.nodes.map(n => String(n.id)));
            
            // Don't clear linkObjects if we're just adding nodes/edges
            const wasEmpty = linkObjects.size === 0;
            if (wasEmpty) {
                appendDebugLine(`updateGraphData initial build, nodes=${filteredGraphData.nodes.length} links=${filteredGraphData.links.length}`);
            } else {
                appendDebugLine(`updateGraphData preserving ${linkObjects.size} link objects, nodes=${filteredGraphData.nodes.length} links=${filteredGraphData.links.length}`);
            }
            
            graph.graphData(filteredGraphData);
            // Give the graph time to build link objects before processing pending pulses
            setTimeout(() => {
                appendDebugLine(`post-update linkObjects count=${linkObjects.size}`);
                // Re-process any pending pulses now that links might be ready
                pendingLinkPulses.forEach((pulses, key) => {
                    const [src, tgt] = key.split('->');
                    if (src && tgt) {
                        pulses.forEach(p => pulseLink(src, tgt, p.colorHex));
                    }
                });
            }, 100);
        }
        
        function applyTheme(index) {
            const theme = themes[index];
            themeButton.querySelector('span:last-of-type').textContent = `Theme: ${theme.name}`;
            ambientLight.color.set(theme.ambientLightColor);
            pointLight.color.set(theme.pointLightColor);
            dirLight1.color.set(theme.dirLight1);
            dirLight2.color.set(theme.dirLight2);
            edgeMaterial.uniforms.color.value.set(theme.edgeColor);
            // Update node materials
            filteredGraphData.nodes.forEach(node => {
                const mat = nodeMaterials[node.id];
                if (mat) {
                    mat.uniforms.baseColor.value.set(...theme.nodeColors[node.type]);
                    mat.uniforms.accentColor.value.set(...theme.accentColors[node.type]);
                }
            });
        }
        
        function toggleTheme() {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(currentThemeIndex);
        }
        
        function toggleMorph() {
            const morphEffect = {
                startTime: clock.getElapsedTime(),
                duration: 2.0,
                update: (elapsed) => {
                    let progress = elapsed / morphEffect.duration;
                    if (progress > 1) progress = 1;
                    const eased = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                    const morphProg = isMorphed ? 1 - eased : eased;
                    scene.traverse(obj => {
                        if (obj.userData.node) {
                            const geo = obj.geometry;
                            const orig = obj.userData.originalPositions;
                            const targ = obj.userData.targetPositions;
                            const pos = geo.attributes.position;
                            for (let i = 0; i < orig.count; i++) {
                                pos.setX(i, THREE.MathUtils.lerp(orig.getX(i), targ.getX(i), morphProg));
                                pos.setY(i, THREE.MathUtils.lerp(orig.getY(i), targ.getY(i), morphProg));
                                pos.setZ(i, THREE.MathUtils.lerp(orig.getZ(i), targ.getZ(i), morphProg));
                            }
                            pos.needsUpdate = true;
                            geo.computeVertexNormals();
                        }
                    });
                },
                end: () => {
                    isMorphed = !isMorphed;
                }
            };
            activeEffects.push(morphEffect);
        }
        
        function setLayout(layout) {
            currentLayout = layout;
            let dagMode = null;
            if (layout === 'layered') dagMode = 'td'; // top-down
            else if (layout === 'radial') dagMode = 'radialout';
            if (typeof graph.dagMode === 'function') {
                graph.dagMode(dagMode);
            }
            if (!dagMode) {
                configureForceSpacing(linkDistanceMultiplier);
            }
            graph.graphData(filteredGraphData);
        }
        
        function activateGraph() {
            // Simulate activation: randomly select a link and pulse it
            const randomLink = filteredGraphData.links[Math.floor(Math.random() * filteredGraphData.links.length)];
            if (randomLink) {
                createPulse(randomLink.source, randomLink.target);
                pulseLink(randomLink.source?.id || randomLink.source, randomLink.target?.id || randomLink.target, 0xe74c3c);
                // Update stats placeholder
                statsDiv.children[0].textContent = `Active: ${parseInt(statsDiv.children[0].textContent.split(': ')[1]) + 1}`;
                statsDiv.children[1].textContent = `Starts: ${parseInt(statsDiv.children[1].textContent.split(': ')[1]) + 1}`;
            }
        }

        function pulseLink(sourceId, targetId, colorHex) {
            try {
                const key = `${sourceId}->${targetId}`;
                let obj = linkObjects.get(key);
                if (!obj) {
                    // Try reverse direction if only INTERFACE_TO_AGENT edge exists
                    const rkey = `${targetId}->${sourceId}`;
                    const robj = linkObjects.get(rkey);
                    // Debug: log what keys exist
                    const allKeys = Array.from(linkObjects.keys());
                    appendDebugLine(`pulse_lookup key=${key} exists=${!!obj} rkey=${rkey} rexists=${!!robj} total_keys=${allKeys.length}`);
                    if (robj) {
                        obj = robj;
                        appendDebugLine(`redirect_pulse ${key} -> ${rkey}`);
                    }
                }
                if (!obj) {
                    // Suppress unmatched for non-graph endpoints like OpenAI
                    const srcKnown = knownNodeIds.has(String(sourceId));
                    const tgtKnown = knownNodeIds.has(String(targetId));
                    if (srcKnown && tgtKnown) {
                        // helpful diagnostics with labels/types
                        const srcInfo = getNodeMeta(sourceId);
                        const tgtInfo = getNodeMeta(targetId);
                        const srcOut = linkKeysForSource(sourceId).slice(0, 10);
                        const srcIn  = linkKeysForTarget(sourceId).slice(0, 10);
                        const tgtOut = linkKeysForSource(targetId).slice(0, 10);
                        const tgtIn  = linkKeysForTarget(targetId).slice(0, 10);
                        appendDebugLine(
                            `UNMATCHED activity link ${key} ` +
                            `src=[${srcInfo.label||'?'} ${srcInfo.type||''} ${srcInfo.id}] ` +
                            `tgt=[${tgtInfo.label||'?'} ${tgtInfo.type||''} ${tgtInfo.id}] ` +
                            `src_out=[${srcOut.join(', ')}] src_in=[${srcIn.join(', ')}] ` +
                            `tgt_out=[${tgtOut.join(', ')}] tgt_in=[${tgtIn.join(', ')}]`
                        );
                    }
                    const arr = pendingLinkPulses.get(key) || [];
                    arr.push({ colorHex });
                    pendingLinkPulses.set(key, arr);
                    return false;
                }
                const pulse = obj.getObjectByName('edgePulse');
                const cylinder = obj.getObjectByName('edgeCylinder');
                if (!pulse || !pulse.material || !pulse.material.uniforms) return false;
                const mat = pulse.material;
                const baseMat = cylinder ? cylinder.material : null;
                const baseColor = new THREE.Color(themes[currentThemeIndex].edgeColor);
                const effect = {
                    startTime: clock.getElapsedTime(),
                    duration: 2.2,  // Increased from 1.6 for better visibility
                    update: (elapsed) => {
                        const progress = elapsed / effect.duration;
                        if (progress > 1) return;
                        const intensity = Math.sin(progress * Math.PI);
                        mat.uniforms.energy.value = 0.4 + intensity * 3.2;
                        mat.uniforms.opacity.value = 0.1 + 0.9 * intensity;
                        mat.uniforms.color.value.set(colorHex);
                        if (baseMat && baseMat.uniforms) {
                            baseMat.uniforms.opacity.value = 0.02 + 0.18 * (1.0 - intensity);
                        }
                    },
                    end: () => {
                        mat.uniforms.energy.value = 0.0;
                        mat.uniforms.opacity.value = 0.0;
                        mat.uniforms.color.value.copy(baseColor);
                        if (baseMat && baseMat.uniforms) {
                            baseMat.uniforms.opacity.value = 0.02;
                        }
                    }
                };
                activeEffects.push(effect);
                return true;
            } catch (_) { return false; }
        }
        
        function createPulse(sourceNode, targetNode) {
            const arcMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(0xff0000) },
                    opacity: { value: 0.0 },
                    energy: { value: 0.0 }
                },
                vertexShader: document.getElementById('edgeVertexShader').textContent,
                fragmentShader: document.getElementById('edgeFragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            const effect = {
                startTime: clock.getElapsedTime(),
                duration: 3.0,
                mesh: null,
                update: (elapsed) => {
                    const progress = elapsed / effect.duration;
                    if (progress > 1) return;
                    const start = new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z);
                    const end = new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z);
                    const mid = start.clone().lerp(end, 0.5);
                    const control = mid.clone().add(new THREE.Vector3(0, start.distanceTo(end) * 0.3, 0));
                    const curve = new THREE.QuadraticBezierCurve3(start, control, end);
                    const geo = new THREE.TubeGeometry(curve, 64, 2, 8, false);
                    if (!effect.mesh) {
                        effect.mesh = new THREE.Mesh(geo, arcMaterial);
                        scene.add(effect.mesh);
                    } else {
                        effect.mesh.geometry.dispose();
                        effect.mesh.geometry = geo;
                    }
                    const intensity = Math.sin(progress * Math.PI);
                    arcMaterial.uniforms.opacity.value = intensity;
                    arcMaterial.uniforms.energy.value = intensity * 2;
                    arcMaterial.uniforms.time.value += clock.getDelta();
                },
                end: () => {
                    if (effect.mesh) {
                        scene.remove(effect.mesh);
                        effect.mesh.geometry.dispose();
                        arcMaterial.dispose();
                    }
                }
            };
            activeEffects.push(effect);
        }

        function getNodePositionById(nodeId) {
            let found = null;
            try {
                scene.traverse(obj => {
                    if (found) return;
                    if (obj.userData && obj.userData.node && String(obj.userData.node.id) === String(nodeId)) {
                        const p = obj.position;
                        found = { x: p.x, y: p.y, z: p.z };
                    }
                });
            } catch (_) {}
            return found;
        }

        function createArcPulseByPositions(srcPos, tgtPos, colorHex) {
            const arcMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(colorHex || 0xff0000) },
                    opacity: { value: 0.0 },
                    energy: { value: 0.0 }
                },
                vertexShader: document.getElementById('edgeVertexShader').textContent,
                fragmentShader: document.getElementById('edgeFragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            const effect = {
                startTime: clock.getElapsedTime(),
                duration: 1.6,
                mesh: null,
                update: (elapsed) => {
                    const progress = elapsed / effect.duration;
                    if (progress > 1) return;
                    const start = new THREE.Vector3(srcPos.x, srcPos.y, srcPos.z);
                    const end = new THREE.Vector3(tgtPos.x, tgtPos.y, tgtPos.z);
                    const mid = start.clone().lerp(end, 0.5);
                    const control = mid.clone().add(new THREE.Vector3(0, start.distanceTo(end) * 0.3, 0));
                    const curve = new THREE.QuadraticBezierCurve3(start, control, end);
                    const geo = new THREE.TubeGeometry(curve, 48, 1.8, 8, false);
                    if (!effect.mesh) {
                        effect.mesh = new THREE.Mesh(geo, arcMaterial);
                        scene.add(effect.mesh);
                    } else {
                        effect.mesh.geometry.dispose();
                        effect.mesh.geometry = geo;
                    }
                    const intensity = Math.sin(progress * Math.PI);
                    arcMaterial.uniforms.opacity.value = 0.2 + 0.8 * intensity;
                    arcMaterial.uniforms.energy.value = intensity * 2.5;
                    arcMaterial.uniforms.time.value += clock.getDelta();
                },
                end: () => {
                    if (effect.mesh) {
                        scene.remove(effect.mesh);
                        effect.mesh.geometry.dispose();
                        arcMaterial.dispose();
                    }
                }
            };
            activeEffects.push(effect);
        }
        
        function refreshGraph() {
            graph.graphData(filteredGraphData);
        }
        
        function loadSnapshot() {
            // Placeholder: load new data
            alert('Load Snapshot functionality not implemented.');
        }
        
        function toggleEdgeLabels() {
            edgeLabelsVisible = !edgeLabelsVisible;
            edgeLabelsButton.querySelector('span:last-of-type').textContent = `Edge Labels: ${edgeLabelsVisible ? 'On' : 'Off'}`;
            scene.traverse(obj => {
                if (obj.name === 'edgeLabel' || (obj.userData && obj.userData.isLinkLabel)) {
                    obj.visible = edgeLabelsVisible;
                }
            });
        }
        
        function toggleDebugLog() {
            // Placeholder
            alert('Debug Log functionality not implemented.');
        }
        
        function toggleDisconnected() {
            updateGraphData();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            graph.tickFrame();
            
            // Update node shaders
            scene.traverse(obj => {
                if (obj.userData.node && obj.material && obj.material.uniforms && obj.material.uniforms.time) {
                    obj.material.uniforms.time.value = time;
                }
                if (obj.material && obj.material.uniforms && obj.material.uniforms.time) {
                    obj.material.uniforms.time.value = time;
                }
            });
            
            // edgeMaterial is cloned per link, so update all clones via traversal above
            
            activeEffects.forEach((effect, i) => {
                const elapsed = time - effect.startTime;
                if (elapsed > effect.duration) {
                    effect.end();
                    activeEffects.splice(i, 1);
                } else {
                    effect.update(elapsed);
                }
            });
            
            controls.update();
            composer.render();
        }
        
        init();
        animate();
    </script>
</body>
</html>