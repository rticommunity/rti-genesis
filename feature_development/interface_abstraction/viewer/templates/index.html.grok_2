<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stunning Graph Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;500;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
       
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #0a0f1a 0%, #020408 100%);
            height: 100vh;
            width: 100vw;
            font-family: 'Inter', 'Orbitron', sans-serif;
        }
       
        #container {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
       
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.01);
            backdrop-filter: blur(40px) saturate(180%);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.02),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
       
        .control-button {
            position: relative;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            padding: 10px 18px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            user-select: none;
            letter-spacing: 0.5px;
            text-transform: none;
            min-width: 100px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-shrink: 0;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 2px rgba(0, 0, 0, 0.24),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .control-button:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow:
                0 12px 36px rgba(0, 0, 0, 0.2),
                0 1px 3px rgba(0,0,0,0.24),
                inset 0 1px 0 rgba(255,255,255,0.15),
                inset 0 -1px 0 rgba(0,0,0,0.1);
        }
       
        .control-button:active {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(0);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 2px rgba(0, 0, 0, 0.24),
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        .control-button > span:last-of-type {
            position: relative;
            z-index: 2;
        }
        .control-button > span:not(:last-of-type) {
            position: absolute;
            display: block;
            box-shadow: 0 0 15px rgba(128, 200, 255, 0.9), 0 0 30px rgba(128, 200, 255, 0.7);
        }
        .control-button > span:nth-child(1) {
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(1) {
            animation: animateBorder1 2s linear infinite;
        }
        .control-button > span:nth-child(2) {
            top: -100%;
            right: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(2) {
            animation: animateBorder2 2s linear infinite;
            animation-delay: 0.5s;
        }
        .control-button > span:nth-child(3) {
            bottom: 0;
            right: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(270deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(3) {
            animation: animateBorder3 2s linear infinite;
            animation-delay: 1s;
        }
        .control-button > span:nth-child(4) {
            bottom: -100%;
            left: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(0deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(4) {
            animation: animateBorder4 2s linear infinite;
            animation-delay: 1.5s;
        }
        @keyframes animateBorder1 { 0% { left: -100%; } 50%, 100% { left: 100%; } }
        @keyframes animateBorder2 { 0% { top: -100%; } 50%, 100% { top: 100%; } }
        @keyframes animateBorder3 { 0% { right: -100%; } 50%, 100% { right: 100%; } }
        @keyframes animateBorder4 { 0% { bottom: -100%; } 50%, 100% { bottom: 100%; } }
        .activate-button {
            background: linear-gradient(135deg,
                rgba(255, 100, 100, 0.15) 0%,
                rgba(255, 50, 50, 0.1) 100%);
            border: 1px solid rgba(255, 100, 100, 0.3);
            color: rgba(255, 150, 150, 0.95);
        }
       
        .activate-button:hover {
            background: linear-gradient(135deg,
                rgba(255, 120, 120, 0.2) 0%,
                rgba(255, 80, 80, 0.15) 100%);
            border-color: rgba(255, 150, 150, 0.4);
            color: rgba(255, 200, 200, 1);
        }
       
        .activate-button > span:not(:last-of-type) {
            box-shadow: 0 0 15px rgba(255, 120, 120, 0.9), 0 0 30px rgba(255, 120, 120, 0.7);
        }
        .activate-button > span:nth-child(1) { background: linear-gradient(90deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(2) { background: linear-gradient(180deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(3) { background: linear-gradient(270deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(4) { background: linear-gradient(0deg, transparent, rgba(255, 120, 120, 1)); }
       
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            line-height: 1.6;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px) saturate(150%);
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
       
        .stats div {
            margin-bottom: 4px;
            padding: 2px 0;
        }
       
        .stats div:last-child {
            margin-bottom: 0;
        }
       
        .control-button .icon {
            width: 16px;
            height: 16px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
       
        .control-button:hover .icon {
            opacity: 1;
        }
       
        .controls::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg,
                rgba(255, 255, 255, 0.05) 0%,
                transparent 25%,
                transparent 75%,
                rgba(255, 255, 255, 0.05) 100%);
            border-radius: 21px;
            z-index: -1;
            opacity: 0.5;
        }
        @media (max-width: 768px) {
             .controls {
                 gap: 8px;
                 bottom: 15px;
                 left: 15px;
                 right: 15px;
                 transform: translateX(0);
                 width: auto;
                 flex-direction: column;
             }
            .control-button {
                 padding: 10px 14px;
                 font-size: 11px;
                 flex-grow: 1;
                 width: 100%;
             }
            .stats {
                 top: 15px;
                 right: 15px;
                 padding: 8px 12px;
             }
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            cursor: pointer;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="stats" id="stats">
        <div>Active: 0</div>
        <div>Starts: 0</div>
        <div>Completes: 0</div>
        <div>Unmatched starts: 0</div>
    </div>
    <div class="controls">
        <button class="control-button" id="refresh">
            <span></span><span></span><span></span><span></span>
            <span>Refresh</span>
        </button>
        <button class="control-button" id="loadSnapshot">
            <span></span><span></span><span></span><span></span>
            <span>Load Snapshot</span>
        </button>
        <button class="control-button" id="edgeLabels">
            <span></span><span></span><span></span><span></span>
            <span>Edge Labels: Off</span>
        </button>
        <button class="control-button" id="debugLog">
            <span></span><span></span><span></span><span></span>
            <span>Debug Log</span>
        </button>
        <button class="control-button" id="layoutForce">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Orbital</span>
        </button>
        <button class="control-button" id="layoutLayered">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Layered</span>
        </button>
        <button class="control-button" id="layoutRadial">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Radial</span>
        </button>
        <label class="checkbox-label" for="disconnected">
            <input type="checkbox" id="disconnected" checked>
            Disconnected
        </label>
        <button class="control-button activate-button" id="activateTrigger">
            <span></span><span></span><span></span><span></span>
            <span>Activate Graph</span>
        </button>
        <button class="control-button" id="toggleTheme">
            <span></span><span></span><span></span><span></span>
            <span>Theme: Inferno</span>
        </button>
        <button class="control-button" id="morphButton">
            <span></span><span></span><span></span><span></span>
            <span>Morph Shape</span>
        </button>
    </div>
    <script id="nodeVertexShader" type="x-shader/x-vertex">
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        void main() {
            vPosition = position;
            vNormal = normal;
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="nodeFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 baseColor;
        uniform vec3 accentColor;
        uniform float energy;
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        float noise(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
        void main() {
            vec2 uv = vUv + time * 0.02;
            float n1 = noise(uv * 8.0);
            float n2 = noise(uv * 16.0);
            float pattern = n1 * 0.7 + n2 * 0.3;
            vec3 color = mix(baseColor, accentColor, pattern);
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.5);
            color += fresnel * accentColor * 0.5;
            color *= (1.0 + energy * 0.8);
            gl_FragColor = vec4(color, 1.0);
        }
    </script>
    <script id="edgeVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="edgeFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 color;
        uniform float opacity;
        uniform float energy;
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            float flow = abs(sin(vUv.x * 15.0 - time * 12.0));
            float pulse = sin(time * 8.0) * 0.5 + 0.5;
            float pattern = pow(flow, 1.5) * (1.0 + pulse * energy);
            float fade = sin(vUv.x * 3.14159);
            vec3 finalColor = color * (pattern * 2.0 + 0.3);
            float alpha = fade * opacity * (pattern + 0.2) * (1.0 + energy);
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.161.0/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        
        let scene, camera, renderer, composer, controls, clock;
        let orrery, activeEffects = [];
        let layerGroups = {};
        let functionGroups = {};
        let nodeObjects = {};
        let edgeObjects = [];
        let currentThemeIndex = 0;
        let isMorphed = false;
        let edgeLabelsVisible = false;
        let currentLayout = 'orbital';
        
        const container = document.getElementById('container');
        const statsDiv = document.getElementById('stats');
        const activateButton = document.getElementById('activateTrigger');
        const refreshButton = document.getElementById('refresh');
        const loadSnapshotButton = document.getElementById('loadSnapshot');
        const edgeLabelsButton = document.getElementById('edgeLabels');
        const debugLogButton = document.getElementById('debugLog');
        const layoutForceButton = document.getElementById('layoutForce');
        const layoutLayeredButton = document.getElementById('layoutLayered');
        const layoutRadialButton = document.getElementById('layoutRadial');
        const disconnectedCheckbox = document.getElementById('disconnected');
        const themeButton = document.getElementById('toggleTheme');
        const morphButton = document.getElementById('morphButton');
        
        const themes = [
            {
                name: 'Inferno',
                nodeColors: { Interface: [0.8, 0.2, 0.1], Agent: [0.6, 0.1, 0.1], Service: [0.9, 0.3, 0.0], Function: [1.0, 0.5, 0.0] },
                accentColors: { Interface: [1.0, 0.6, 0.2], Agent: [1.0, 0.4, 0.1], Service: [1.0, 0.8, 0.3], Function: [1.0, 0.7, 0.4] },
                edgeColor: 0xffccaa,
                ringColors: { Interface: 0x0000ff, Agent: 0x00ff00, Service: 0xffa500, Function: 0xffff00 },
                ambientLightColor: 0x401008,
                pointLightColor: 0xffcc88,
                dirLight1: 0xff6600,
                dirLight2: 0xdd3300
            },
            {
                name: 'Veridian',
                nodeColors: { Interface: [0.2, 0.8, 0.5], Agent: [0.1, 0.6, 0.7], Service: [0.5, 0.8, 0.2], Function: [0.3, 0.7, 0.4] },
                accentColors: { Interface: [0.8, 1.0, 0.9], Agent: [0.5, 0.9, 1.0], Service: [0.9, 1.0, 0.6], Function: [0.6, 0.9, 0.7] },
                edgeColor: 0xeeffee,
                ringColors: { Interface: 0x00ffff, Agent: 0x00ffaa, Service: 0xaaff00, Function: 0x00ccff },
                ambientLightColor: 0x0a3024,
                pointLightColor: 0xccffdd,
                dirLight1: 0x33cc88,
                dirLight2: 0x4488cc
            },
            {
                name: 'Celestial',
                nodeColors: { Interface: [1.0, 0.4, 0.4], Agent: [0.3, 0.8, 0.3], Service: [0.3, 0.4, 1.0], Function: [0.5, 0.5, 1.0] },
                accentColors: { Interface: [1.0, 0.8, 0.2], Agent: [0.6, 1.0, 0.8], Service: [0.8, 0.6, 1.0], Function: [0.7, 0.7, 1.0] },
                edgeColor: 0xffeebb,
                ringColors: { Interface: 0xff4444, Agent: 0x44ff88, Service: 0x4488ff, Function: 0xff88cc },
                ambientLightColor: 0x1a2440,
                pointLightColor: 0xffe4b5,
                dirLight1: 0x4488ff,
                dirLight2: 0x8844ff
            }
        ];
        
        // Sample graph data
        const graphData = {
            nodes: [
                { id: 'i1', type: 'Interface', name: 'Interface1' },
                { id: 'i2', type: 'Interface', name: 'Interface2' },
                { id: 'a1', type: 'Agent', name: 'Agent1' },
                { id: 'a2', type: 'Agent', name: 'Agent2' },
                { id: 's1', type: 'Service', name: 'Service1' },
                { id: 's2', type: 'Service', name: 'Service2' },
                { id: 'f1', type: 'Function', name: 'Function1' },
                { id: 'f2', type: 'Function', name: 'Function2' },
                { id: 'd1', type: 'Interface', name: 'Disconnected1' } // Disconnected node
            ],
            links: [
                { source: 'i1', target: 'a1' },
                { source: 'i2', target: 'a2' },
                { source: 'a1', target: 'a2' },
                { source: 'a1', target: 's1' },
                { source: 'a2', target: 's2' },
                { source: 's1', target: 'f1' },
                { source: 's2', target: 'f2' }
            ]
        };
        
        let filteredGraphData = {...graphData};
        
        const layerConfig = {
            'Interface': { y: 40, radius: 50, rotationSpeed: 0.1 },
            'Agent': { y: 0, radius: 70, rotationSpeed: 0.08 },
            'Service': { y: -40, radius: 90, rotationSpeed: 0.06 }
        };
        
        const functionConfig = { radius: 15, rotationSpeed: 0.3, nodeSize: 4 };
        
        let ambientLight, pointLight, dirLight1, dirLight2;
        
        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(100, 80, 100);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            
            setupLighting();
            setupPostProcessing();
            createEnvironment();
            orrery = new THREE.Group();
            scene.add(orrery);
            updateGraphData();
            buildGraph();
            applyTheme(currentThemeIndex);
            
            window.addEventListener('resize', onWindowResize);
            activateButton.addEventListener('click', activateGraph);
            refreshButton.addEventListener('click', refreshGraph);
            loadSnapshotButton.addEventListener('click', loadSnapshot);
            edgeLabelsButton.addEventListener('click', toggleEdgeLabels);
            debugLogButton.addEventListener('click', toggleDebugLog);
            // Layout buttons not fully implemented, placeholder
            layoutForceButton.addEventListener('click', () => setLayout('orbital'));
            layoutLayeredButton.addEventListener('click', () => setLayout('layered'));
            layoutRadialButton.addEventListener('click', () => setLayout('radial'));
            disconnectedCheckbox.addEventListener('change', toggleDisconnected);
            themeButton.addEventListener('click', toggleTheme);
            morphButton.addEventListener('click', toggleMorph);
        }
        
        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0x1a2440, 0.8);
            scene.add(ambientLight);
            
            pointLight = new THREE.PointLight(0xffe4b5, 3, 500);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
            
            dirLight1 = new THREE.DirectionalLight(0x4488ff, 0.5);
            dirLight1.position.set(-200, 100, -100);
            scene.add(dirLight1);
            
            dirLight2 = new THREE.DirectionalLight(0x8844ff, 0.3);
            dirLight2.position.set(100, -50, 200);
            scene.add(dirLight2);
        }
        
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.1);
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());
        }
        
        function createEnvironment() {
            const layers = [
                { count: 5000, distance: [200, 500], size: [0.5, 1.0], color: 0x6688bb },
                { count: 3000, distance: [500, 1000], size: [0.8, 1.5], color: 0x88aadd },
                { count: 2000, distance: [1000, 2000], size: [1.0, 2.0], color: 0xaaccff }
            ];
            layers.forEach(layer => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(layer.count * 3);
                const colors = new Float32Array(layer.count * 3);
                const sizes = new Float32Array(layer.count);
                const color = new THREE.Color(layer.color);
                for (let i = 0; i < layer.count; i++) {
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = layer.distance[0] + Math.random() * (layer.distance[1] - layer.distance[0]);
                    positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i*3+2] = r * Math.cos(phi);
                    colors[i*3] = color.r;
                    colors[i*3+1] = color.g;
                    colors[i*3+2] = color.b;
                    sizes[i] = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                const material = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.7
                });
                const starfield = new THREE.Points(geometry, material);
                scene.add(starfield);
            });
        }
        
        function updateGraphData() {
            if (!disconnectedCheckbox.checked) {
                const connectedNodes = new Set();
                filteredGraphData.links.forEach(link => {
                    connectedNodes.add(link.source);
                    connectedNodes.add(link.target);
                });
                filteredGraphData.nodes = graphData.nodes.filter(node => connectedNodes.has(node.id));
                filteredGraphData.links = graphData.links.filter(link => connectedNodes.has(link.source) && connectedNodes.has(link.target));
            } else {
                filteredGraphData = {...graphData};
            }
            buildGraph();
        }
        
        function buildGraph() {
            // Clear previous
            Object.values(layerGroups).forEach(group => orrery.remove(group));
            Object.values(functionGroups).forEach(group => orrery.remove(group));
            edgeObjects.forEach(edge => {
                orrery.remove(edge.mesh);
                if (edge.label) orrery.remove(edge.label);
            });
            layerGroups = {};
            functionGroups = {};
            nodeObjects = {};
            edgeObjects = [];
            
            // Normalize links
            filteredGraphData.links = filteredGraphData.links.map(link => ({
                source: typeof link.source === 'string' ? link.source : link.source.id,
                target: typeof link.target === 'string' ? link.target : link.target.id
            }));
            
            // Create layer groups
            ['Interface', 'Agent', 'Service'].forEach(type => {
                layerGroups[type] = new THREE.Group();
                layerGroups[type].position.y = layerConfig[type].y;
                orrery.add(layerGroups[type]);
                
                // Ring
                const ringGeo = new THREE.TorusGeometry(layerConfig[type].radius, 1, 16, 100);
                const ringMat = new THREE.MeshBasicMaterial({ color: themes[currentThemeIndex].ringColors[type], transparent: true, opacity: 0.5 });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                layerGroups[type].add(ring);
            });
            
            // Place main nodes
            ['Interface', 'Agent', 'Service'].forEach(type => {
                const nodesInLayer = filteredGraphData.nodes.filter(n => n.type === type);
                if (nodesInLayer.length === 0) return;
                const num = nodesInLayer.length;
                nodesInLayer.forEach((node, i) => {
                    const size = type === 'Service' ? 6 : 5;
                    const geo = new THREE.IcosahedronGeometry(size, 3);
                    const mat = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0.0 },
                            baseColor: { value: new THREE.Vector3(...themes[currentThemeIndex].nodeColors[type]) },
                            accentColor: { value: new THREE.Vector3(...themes[currentThemeIndex].accentColors[type]) },
                            energy: { value: 0.0 }
                        },
                        vertexShader: document.getElementById('nodeVertexShader').textContent,
                        fragmentShader: document.getElementById('nodeFragmentShader').textContent
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    const angle = (2 * Math.PI * i / num) + Math.random() * 0.1; // slight random
                    const x = layerConfig[type].radius * Math.cos(angle);
                    const z = layerConfig[type].radius * Math.sin(angle);
                    mesh.position.set(x, 0, z);
                    layerGroups[type].add(mesh);
                    nodeObjects[node.id] = mesh;
                    
                    // Morph data
                    mesh.userData.originalPositions = geo.attributes.position.clone();
                    const targetPos = new Float32Array(geo.attributes.position.count * 3);
                    for (let j = 0; j < geo.attributes.position.count; j++) {
                        const p = new THREE.Vector3().fromBufferAttribute(geo.attributes.position, j);
                        const cubeP = getCubePosition(p).multiplyScalar(size);
                        targetPos[j*3] = cubeP.x;
                        targetPos[j*3+1] = cubeP.y;
                        targetPos[j*3+2] = cubeP.z;
                    }
                    mesh.userData.targetPositions = new THREE.BufferAttribute(targetPos, 3);
                });
            });
            
            // Service functions
            const serviceFunctions = {};
            filteredGraphData.links.forEach(link => {
                const src = filteredGraphData.nodes.find(n => n.id === link.source);
                const tgt = filteredGraphData.nodes.find(n => n.id === link.target);
                if (src && tgt && src.type === 'Service' && tgt.type === 'Function') {
                    if (!serviceFunctions[src.id]) serviceFunctions[src.id] = [];
                    serviceFunctions[src.id].push(tgt);
                }
            });
            
            Object.keys(serviceFunctions).forEach(serviceId => {
                const funcGroup = new THREE.Group();
                const serviceMesh = nodeObjects[serviceId];
                if (!serviceMesh) return;
                serviceMesh.add(funcGroup);
                functionGroups[serviceId] = funcGroup;
                
                // Small ring
                const ringGeo = new THREE.TorusGeometry(functionConfig.radius, 0.5, 8, 50);
                const ringMat = new THREE.MeshBasicMaterial({ color: themes[currentThemeIndex].ringColors['Function'], transparent: true, opacity: 0.3 });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                funcGroup.add(ring);
                
                const funcs = serviceFunctions[serviceId];
                const num = funcs.length;
                funcs.forEach((func, i) => {
                    const geo = new THREE.IcosahedronGeometry(functionConfig.nodeSize, 3);
                    const mat = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0.0 },
                            baseColor: { value: new THREE.Vector3(...themes[currentThemeIndex].nodeColors['Function']) },
                            accentColor: { value: new THREE.Vector3(...themes[currentThemeIndex].accentColors['Function']) },
                            energy: { value: 0.0 }
                        },
                        vertexShader: document.getElementById('nodeVertexShader').textContent,
                        fragmentShader: document.getElementById('nodeFragmentShader').textContent
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    const angle = 2 * Math.PI * i / num;
                    mesh.position.set(functionConfig.radius * Math.cos(angle), 0, functionConfig.radius * Math.sin(angle));
                    funcGroup.add(mesh);
                    nodeObjects[func.id] = mesh;
                    
                    // Morph data
                    mesh.userData.originalPositions = geo.attributes.position.clone();
                    const targetPos = new Float32Array(geo.attributes.position.count * 3);
                    for (let j = 0; j < geo.attributes.position.count; j++) {
                        const p = new THREE.Vector3().fromBufferAttribute(geo.attributes.position, j);
                        const cubeP = getCubePosition(p).multiplyScalar(functionConfig.nodeSize);
                        targetPos[j*3] = cubeP.x;
                        targetPos[j*3+1] = cubeP.y;
                        targetPos[j*3+2] = cubeP.z;
                    }
                    mesh.userData.targetPositions = new THREE.BufferAttribute(targetPos, 3);
                });
            });
            
            // Edges
            filteredGraphData.links.forEach(link => {
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        color: { value: new THREE.Color(themes[currentThemeIndex].edgeColor) },
                        opacity: { value: 0.8 },
                        energy: { value: 0.0 }
                    },
                    vertexShader: document.getElementById('edgeVertexShader').textContent,
                    fragmentShader: document.getElementById('edgeFragmentShader').textContent,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const geo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3([new THREE.Vector3(), new THREE.Vector3()]), 32, 1, 8, false);
                const mesh = new THREE.Mesh(geo, mat);
                orrery.add(mesh);
                
                const edgeObj = { mesh, source: link.source, target: link.target, material: mat };
                
                // Label
                const label = createLabelSprite(`${link.source} -> ${link.target}`);
                label.visible = edgeLabelsVisible;
                orrery.add(label);
                edgeObj.label = label;
                
                edgeObjects.push(edgeObj);
            });
        }
        
        function getCubePosition(p) {
            const v = p.clone().normalize();
            const max = Math.max(Math.abs(v.x), Math.abs(v.y), Math.abs(v.z));
            return v.divideScalar(max);
        }
        
        function createLabelSprite(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.font = 'bold 40px Inter';
            ctx.fillText(text, 10, 50);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(20, 5, 1);
            return sprite;
        }
        
        function updateEdges() {
            edgeObjects.forEach(edge => {
                const srcMesh = nodeObjects[edge.source];
                const tgtMesh = nodeObjects[edge.target];
                if (!srcMesh || !tgtMesh) return;
                const srcPos = srcMesh.getWorldPosition(new THREE.Vector3());
                const tgtPos = tgtMesh.getWorldPosition(new THREE.Vector3());
                const curve = new THREE.CatmullRomCurve3([srcPos, tgtPos]);
                const newGeo = new THREE.TubeGeometry(curve, 32, 1, 8, false);
                edge.mesh.geometry.dispose();
                edge.mesh.geometry = newGeo;
                
                if (edge.label) {
                    const mid = new THREE.Vector3().lerpVectors(srcPos, tgtPos, 0.5);
                    edge.label.position.copy(mid);
                    edge.label.lookAt(camera.position);
                    edge.label.visible = edgeLabelsVisible;
                }
            });
        }
        
        function applyTheme(index) {
            const theme = themes[index];
            themeButton.querySelector('span:last-of-type').textContent = `Theme: ${theme.name}`;
            ambientLight.color.set(theme.ambientLightColor);
            pointLight.color.set(theme.pointLightColor);
            dirLight1.color.set(theme.dirLight1);
            dirLight2.color.set(theme.dirLight2);
            
            // Update node materials
            Object.values(nodeObjects).forEach(mesh => {
                const type = filteredGraphData.nodes.find(n => nodeObjects[n.id] === mesh).type;
                mesh.material.uniforms.baseColor.value.set(...theme.nodeColors[type]);
                mesh.material.uniforms.accentColor.value.set(...theme.accentColors[type]);
            });
            
            // Update edge materials
            edgeObjects.forEach(edge => {
                edge.material.uniforms.color.value.set(theme.edgeColor);
            });
            
            // Update rings
            ['Interface', 'Agent', 'Service'].forEach(type => {
                if (layerGroups[type]) {
                    const ring = layerGroups[type].children[0]; // assuming first child is ring
                    ring.material.color.set(theme.ringColors[type]);
                }
            });
            Object.values(functionGroups).forEach(group => {
                const ring = group.children[0];
                ring.material.color.set(theme.ringColors['Function']);
            });
        }
        
        function toggleTheme() {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(currentThemeIndex);
        }
        
        function toggleMorph() {
            const morphEffect = {
                startTime: clock.getElapsedTime(),
                duration: 2.0,
                update: (elapsed) => {
                    let progress = elapsed / this.duration;
                    if (progress > 1) progress = 1;
                    const eased = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                    const morphProg = isMorphed ? 1 - eased : eased;
                    Object.values(nodeObjects).forEach(mesh => {
                        const geo = mesh.geometry;
                        const orig = mesh.userData.originalPositions;
                        const targ = mesh.userData.targetPositions;
                        const pos = geo.attributes.position;
                        for (let i = 0; i < orig.count; i++) {
                            pos.setX(i, THREE.MathUtils.lerp(orig.getX(i), targ.getX(i), morphProg));
                            pos.setY(i, THREE.MathUtils.lerp(orig.getY(i), targ.getY(i), morphProg));
                            pos.setZ(i, THREE.MathUtils.lerp(orig.getZ(i), targ.getZ(i), morphProg));
                        }
                        pos.needsUpdate = true;
                        geo.computeVertexNormals();
                    });
                },
                end: () => {
                    isMorphed = !isMorphed;
                }
            };
            activeEffects.push(morphEffect);
        }
        
        function setLayout(layout) {
            currentLayout = layout;
            // For now, only orbital implemented; layered and radial could reposition nodes differently
            buildGraph();
        }
        
        function activateGraph() {
            const randomLinkIndex = Math.floor(Math.random() * filteredGraphData.links.length);
            const randomLink = filteredGraphData.links[randomLinkIndex];
            if (randomLink) {
                const srcMesh = nodeObjects[randomLink.source];
                const tgtMesh = nodeObjects[randomLink.target];
                if (srcMesh && tgtMesh) {
                    createPulse(srcMesh, tgtMesh);
                    // Update stats placeholder
                    let active = parseInt(statsDiv.children[0].textContent.split(': ')[1]) + 1;
                    statsDiv.children[0].textContent = `Active: ${active}`;
                    let starts = parseInt(statsDiv.children[1].textContent.split(': ')[1]) + 1;
                    statsDiv.children[1].textContent = `Starts: ${starts}`;
                }
            }
        }
        
        function createPulse(obj1, obj2) {
            const arcMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(0xff0000) },
                    opacity: { value: 0.0 },
                    energy: { value: 0.0 }
                },
                vertexShader: document.getElementById('edgeVertexShader').textContent,
                fragmentShader: document.getElementById('edgeFragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            const effect = {
                mesh: null,
                startTime: clock.getElapsedTime(),
                duration: 3.0,
                obj1,
                obj2,
                update: (elapsed) => {
                    const progress = elapsed / this.duration;
                    if (progress > 1) return;
                    const p1 = this.obj1.getWorldPosition(new THREE.Vector3());
                    const p2 = this.obj2.getWorldPosition(new THREE.Vector3());
                    const mid = p1.clone().lerp(p2, 0.5);
                    const control = mid.clone().add(new THREE.Vector3(0, p1.distanceTo(p2) * 0.3, 0));
                    const curve = new THREE.QuadraticBezierCurve3(p1, control, p2);
                    const geo = new THREE.TubeGeometry(curve, 64, 2, 8, false);
                    if (!this.mesh) {
                        this.mesh = new THREE.Mesh(geo, arcMaterial);
                        orrery.add(this.mesh);
                    } else {
                        this.mesh.geometry.dispose();
                        this.mesh.geometry = geo;
                    }
                    const intensity = Math.sin(progress * Math.PI);
                    arcMaterial.uniforms.opacity.value = intensity;
                    arcMaterial.uniforms.energy.value = intensity * 2;
                    arcMaterial.uniforms.time.value += clock.getDelta();
                },
                end: () => {
                    if (this.mesh) {
                        orrery.remove(this.mesh);
                        this.mesh.geometry.dispose();
                        arcMaterial.dispose();
                    }
                }
            };
            activeEffects.push(effect);
        }
        
        function refreshGraph() {
            buildGraph();
        }
        
        function loadSnapshot() {
            alert('Load Snapshot functionality not implemented.');
        }
        
        function toggleEdgeLabels() {
            edgeLabelsVisible = !edgeLabelsVisible;
            edgeLabelsButton.querySelector('span:last-of-type').textContent = `Edge Labels: ${edgeLabelsVisible ? 'On' : 'Off'}`;
            edgeObjects.forEach(edge => {
                if (edge.label) edge.label.visible = edgeLabelsVisible;
            });
        }
        
        function toggleDebugLog() {
            alert('Debug Log functionality not implemented.');
        }
        
        function toggleDisconnected() {
            updateGraphData();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Rotate layers
            Object.entries(layerGroups).forEach(([type, group]) => {
                group.rotation.y += delta * layerConfig[type].rotationSpeed;
            });
            
            // Rotate function groups
            Object.values(functionGroups).forEach(group => {
                group.rotation.y += delta * functionConfig.rotationSpeed;
            });
            
            // Update node shaders
            Object.values(nodeObjects).forEach(mesh => {
                mesh.material.uniforms.time.value = time;
            });
            
            // Update edge shaders
            edgeObjects.forEach(edge => {
                edge.material.uniforms.time.value = time;
            });
            
            updateEdges();
            
            activeEffects.forEach((effect, i) => {
                const elapsed = time - effect.startTime;
                if (elapsed > effect.duration) {
                    effect.end();
                    activeEffects.splice(i, 1);
                } else {
                    effect.update(elapsed);
                }
            });
            
            controls.update();
            composer.render();
        }
        
        init();
        animate();
    </script>
</body>
</html>