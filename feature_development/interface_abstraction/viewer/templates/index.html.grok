<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stunning Graph Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;500;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
       
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #0a0f1a 0%, #020408 100%);
            height: 100vh;
            width: 100vw;
            font-family: 'Inter', 'Orbitron', sans-serif;
        }
       
        #container {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
       
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.01);
            backdrop-filter: blur(40px) saturate(180%);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.02),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
       
        .control-button {
            position: relative;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            padding: 10px 18px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            user-select: none;
            letter-spacing: 0.5px;
            text-transform: none;
            min-width: 100px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-shrink: 0;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 2px rgba(0, 0, 0, 0.24),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .control-button:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow:
                0 12px 36px rgba(0, 0, 0, 0.2),
                0 1px 3px rgba(0,0,0,0.24),
                inset 0 1px 0 rgba(255,255,255,0.15),
                inset 0 -1px 0 rgba(0,0,0,0.1);
        }
       
        .control-button:active {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(0);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 2px rgba(0, 0, 0, 0.24),
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        .control-button > span:last-of-type {
            position: relative;
            z-index: 2;
        }
        .control-button > span:not(:last-of-type) {
            position: absolute;
            display: block;
            box-shadow: 0 0 15px rgba(128, 200, 255, 0.9), 0 0 30px rgba(128, 200, 255, 0.7);
        }
        .control-button > span:nth-child(1) {
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(1) {
            animation: animateBorder1 2s linear infinite;
        }
        .control-button > span:nth-child(2) {
            top: -100%;
            right: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(2) {
            animation: animateBorder2 2s linear infinite;
            animation-delay: 0.5s;
        }
        .control-button > span:nth-child(3) {
            bottom: 0;
            right: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(270deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(3) {
            animation: animateBorder3 2s linear infinite;
            animation-delay: 1s;
        }
        .control-button > span:nth-child(4) {
            bottom: -100%;
            left: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(0deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(4) {
            animation: animateBorder4 2s linear infinite;
            animation-delay: 1.5s;
        }
        @keyframes animateBorder1 { 0% { left: -100%; } 50%, 100% { left: 100%; } }
        @keyframes animateBorder2 { 0% { top: -100%; } 50%, 100% { top: 100%; } }
        @keyframes animateBorder3 { 0% { right: -100%; } 50%, 100% { right: 100%; } }
        @keyframes animateBorder4 { 0% { bottom: -100%; } 50%, 100% { bottom: 100%; } }
        .activate-button {
            background: linear-gradient(135deg,
                rgba(255, 100, 100, 0.15) 0%,
                rgba(255, 50, 50, 0.1) 100%);
            border: 1px solid rgba(255, 100, 100, 0.3);
            color: rgba(255, 150, 150, 0.95);
        }
       
        .activate-button:hover {
            background: linear-gradient(135deg,
                rgba(255, 120, 120, 0.2) 0%,
                rgba(255, 80, 80, 0.15) 100%);
            border-color: rgba(255, 150, 150, 0.4);
            color: rgba(255, 200, 200, 1);
        }
       
        .activate-button > span:not(:last-of-type) {
            box-shadow: 0 0 15px rgba(255, 120, 120, 0.9), 0 0 30px rgba(255, 120, 120, 0.7);
        }
        .activate-button > span:nth-child(1) { background: linear-gradient(90deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(2) { background: linear-gradient(180deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(3) { background: linear-gradient(270deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(4) { background: linear-gradient(0deg, transparent, rgba(255, 120, 120, 1)); }
       
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            line-height: 1.6;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px) saturate(150%);
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
       
        .stats div {
            margin-bottom: 4px;
            padding: 2px 0;
        }
       
        .stats div:last-child {
            margin-bottom: 0;
        }
       
        .control-button .icon {
            width: 16px;
            height: 16px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
       
        .control-button:hover .icon {
            opacity: 1;
        }
       
        .controls::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg,
                rgba(255, 255, 255, 0.05) 0%,
                transparent 25%,
                transparent 75%,
                rgba(255, 255, 255, 0.05) 100%);
            border-radius: 21px;
            z-index: -1;
            opacity: 0.5;
        }
        @media (max-width: 768px) {
             .controls {
                 gap: 8px;
                 bottom: 15px;
                 left: 15px;
                 right: 15px;
                 transform: translateX(0);
                 width: auto;
                 flex-direction: column;
             }
            .control-button {
                 padding: 10px 14px;
                 font-size: 11px;
                 flex-grow: 1;
                 width: 100%;
             }
            .stats {
                 top: 15px;
                 right: 15px;
                 padding: 8px 12px;
             }
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            cursor: pointer;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="stats" id="stats">
        <div>Active: 0</div>
        <div>Starts: 0</div>
        <div>Completes: 0</div>
        <div>Unmatched starts: 0</div>
    </div>
    <div class="controls">
        <button class="control-button" id="refresh">
            <span></span><span></span><span></span><span></span>
            <span>Refresh</span>
        </button>
        <button class="control-button" id="loadSnapshot">
            <span></span><span></span><span></span><span></span>
            <span>Load Snapshot</span>
        </button>
        <button class="control-button" id="edgeLabels">
            <span></span><span></span><span></span><span></span>
            <span>Edge Labels: Off</span>
        </button>
        <button class="control-button" id="debugLog">
            <span></span><span></span><span></span><span></span>
            <span>Debug Log</span>
        </button>
        <button class="control-button" id="layoutForce">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Force</span>
        </button>
        <button class="control-button" id="layoutLayered">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Layered</span>
        </button>
        <button class="control-button" id="layoutRadial">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Radial</span>
        </button>
        <label class="checkbox-label" for="disconnected">
            <input type="checkbox" id="disconnected" checked>
            Disconnected
        </label>
        <button class="control-button activate-button" id="activateTrigger">
            <span></span><span></span><span></span><span></span>
            <span>Activate Graph</span>
        </button>
        <button class="control-button" id="toggleTheme">
            <span></span><span></span><span></span><span></span>
            <span>Theme: Inferno</span>
        </button>
        <button class="control-button" id="morphButton">
            <span></span><span></span><span></span><span></span>
            <span>Morph Shape</span>
        </button>
    </div>
    <script id="nodeVertexShader" type="x-shader/x-vertex">
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        void main() {
            vPosition = position;
            vNormal = normal;
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="nodeFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 baseColor;
        uniform vec3 accentColor;
        uniform float energy;
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        float noise(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
        void main() {
            vec2 uv = vUv + time * 0.02;
            float n1 = noise(uv * 8.0);
            float n2 = noise(uv * 16.0);
            float pattern = n1 * 0.7 + n2 * 0.3;
            vec3 color = mix(baseColor, accentColor, pattern);
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.5);
            color += fresnel * accentColor * 0.5;
            color *= (1.0 + energy * 0.8);
            gl_FragColor = vec4(color, 1.0);
        }
    </script>
    <script id="edgeVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="edgeFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 color;
        uniform float opacity;
        uniform float energy;
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            float flow = abs(sin(vUv.x * 15.0 - time * 12.0));
            float pulse = sin(time * 8.0) * 0.5 + 0.5;
            float pattern = pow(flow, 1.5) * (1.0 + pulse * energy);
            float fade = sin(vUv.x * 3.14159);
            vec3 finalColor = color * (pattern * 2.0 + 0.3);
            float alpha = fade * opacity * (pattern + 0.2) * (1.0 + energy);
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.161.0/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/",
            "three-forcegraph": "https://unpkg.com/three-forcegraph"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import ForceGraph3D from 'three-forcegraph';
        
        let scene, camera, renderer, composer, controls, clock;
        let graph, activeEffects = [];
        let currentThemeIndex = 0;
        let isMorphed = false;
        let currentLayout = 'force';
        let edgeLabelsVisible = false;
        
        const container = document.getElementById('container');
        const statsDiv = document.getElementById('stats');
        const activateButton = document.getElementById('activateTrigger');
        const refreshButton = document.getElementById('refresh');
        const loadSnapshotButton = document.getElementById('loadSnapshot');
        const edgeLabelsButton = document.getElementById('edgeLabels');
        const debugLogButton = document.getElementById('debugLog');
        const layoutForceButton = document.getElementById('layoutForce');
        const layoutLayeredButton = document.getElementById('layoutLayered');
        const layoutRadialButton = document.getElementById('layoutRadial');
        const disconnectedCheckbox = document.getElementById('disconnected');
        const themeButton = document.getElementById('toggleTheme');
        const morphButton = document.getElementById('morphButton');
        
        const themes = [
            {
                name: 'Inferno',
                nodeColors: { Interface: [0.8, 0.2, 0.1], Agent: [0.6, 0.1, 0.1], Service: [0.9, 0.3, 0.0], Function: [1.0, 0.5, 0.0] },
                accentColors: { Interface: [1.0, 0.6, 0.2], Agent: [1.0, 0.4, 0.1], Service: [1.0, 0.8, 0.3], Function: [1.0, 0.7, 0.4] },
                edgeColor: 0xffccaa,
                ambientLightColor: 0x401008,
                pointLightColor: 0xffcc88,
                dirLight1: 0xff6600,
                dirLight2: 0xdd3300
            },
            {
                name: 'Veridian',
                nodeColors: { Interface: [0.2, 0.8, 0.5], Agent: [0.1, 0.6, 0.7], Service: [0.5, 0.8, 0.2], Function: [0.3, 0.7, 0.4] },
                accentColors: { Interface: [0.8, 1.0, 0.9], Agent: [0.5, 0.9, 1.0], Service: [0.9, 1.0, 0.6], Function: [0.6, 0.9, 0.7] },
                edgeColor: 0xeeffee,
                ambientLightColor: 0x0a3024,
                pointLightColor: 0xccffdd,
                dirLight1: 0x33cc88,
                dirLight2: 0x4488cc
            },
            {
                name: 'Celestial',
                nodeColors: { Interface: [1.0, 0.4, 0.4], Agent: [0.3, 0.8, 0.3], Service: [0.3, 0.4, 1.0], Function: [0.5, 0.5, 1.0] },
                accentColors: { Interface: [1.0, 0.8, 0.2], Agent: [0.6, 1.0, 0.8], Service: [0.8, 0.6, 1.0], Function: [0.7, 0.7, 1.0] },
                edgeColor: 0xffeebb,
                ambientLightColor: 0x1a2440,
                pointLightColor: 0xffe4b5,
                dirLight1: 0x4488ff,
                dirLight2: 0x8844ff
            }
        ];
        
        // Sample graph data
        const graphData = {
            nodes: [
                { id: 'i1', type: 'Interface', name: 'Interface1' },
                { id: 'i2', type: 'Interface', name: 'Interface2' },
                { id: 'a1', type: 'Agent', name: 'Agent1' },
                { id: 'a2', type: 'Agent', name: 'Agent2' },
                { id: 's1', type: 'Service', name: 'Service1' },
                { id: 's2', type: 'Service', name: 'Service2' },
                { id: 'f1', type: 'Function', name: 'Function1' },
                { id: 'f2', type: 'Function', name: 'Function2' },
                { id: 'd1', type: 'Interface', name: 'Disconnected1' } // Disconnected node
            ],
            links: [
                { source: 'i1', target: 'a1' },
                { source: 'i2', target: 'a2' },
                { source: 'a1', target: 's1' },
                { source: 'a2', target: 's2' },
                { source: 's1', target: 'f1' },
                { source: 's2', target: 'f2' }
            ]
        };
        
        let filteredGraphData = {...graphData};
        
        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(100, 80, 100);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            
            setupLighting();
            setupPostProcessing();
            createEnvironment();
            setupGraph();
            applyTheme(currentThemeIndex);
            applyLayout(currentLayout);
            
            window.addEventListener('resize', onWindowResize);
            activateButton.addEventListener('click', activateGraph);
            refreshButton.addEventListener('click', refreshGraph);
            loadSnapshotButton.addEventListener('click', loadSnapshot);
            edgeLabelsButton.addEventListener('click', toggleEdgeLabels);
            debugLogButton.addEventListener('click', toggleDebugLog);
            layoutForceButton.addEventListener('click', () => setLayout('force'));
            layoutLayeredButton.addEventListener('click', () => setLayout('layered'));
            layoutRadialButton.addEventListener('click', () => setLayout('radial'));
            disconnectedCheckbox.addEventListener('change', toggleDisconnected);
            themeButton.addEventListener('click', toggleTheme);
            morphButton.addEventListener('click', toggleMorph);
        }
        
        let ambientLight, pointLight, dirLight1, dirLight2;
        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0x1a2440, 0.8);
            scene.add(ambientLight);
            
            pointLight = new THREE.PointLight(0xffe4b5, 3, 500);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
            
            dirLight1 = new THREE.DirectionalLight(0x4488ff, 0.5);
            dirLight1.position.set(-200, 100, -100);
            scene.add(dirLight1);
            
            dirLight2 = new THREE.DirectionalLight(0x8844ff, 0.3);
            dirLight2.position.set(100, -50, 200);
            scene.add(dirLight2);
        }
        
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.1);
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());
        }
        
        function createEnvironment() {
            // Similar to example, add starfield layers
            const layers = [
                { count: 5000, distance: [200, 500], size: [0.5, 1.0], color: 0x6688bb },
                { count: 3000, distance: [500, 1000], size: [0.8, 1.5], color: 0x88aadd },
                { count: 2000, distance: [1000, 2000], size: [1.0, 2.0], color: 0xaaccff }
            ];
            layers.forEach(layer => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(layer.count * 3);
                const colors = new Float32Array(layer.count * 3);
                const sizes = new Float32Array(layer.count);
                const color = new THREE.Color(layer.color);
                for (let i = 0; i < layer.count; i++) {
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = layer.distance[0] + Math.random() * (layer.distance[1] - layer.distance[0]);
                    positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i*3+2] = r * Math.cos(phi);
                    colors[i*3] = color.r;
                    colors[i*3+1] = color.g;
                    colors[i*3+2] = color.b;
                    sizes[i] = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                const material = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.7
                });
                const starfield = new THREE.Points(geometry, material);
                scene.add(starfield);
            });
        }
        
        let nodeMaterials = {};
        let edgeMaterial;
        function setupGraph() {
            graph = new ForceGraph3D({
                extraRenderers: [] // If needed for custom
            });
            scene.add(graph);
            
            // Custom node object
            graph.nodeThreeObject(node => {
                const geo = new THREE.IcosahedronGeometry(5 + Math.random() * 5, 3); // Size based on something
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        baseColor: { value: new THREE.Vector3(...themes[currentThemeIndex].nodeColors[node.type]) },
                        accentColor: { value: new THREE.Vector3(...themes[currentThemeIndex].accentColors[node.type]) },
                        energy: { value: 0.0 }
                    },
                    vertexShader: document.getElementById('nodeVertexShader').textContent,
                    fragmentShader: document.getElementById('nodeFragmentShader').textContent
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.userData.node = node;
                mesh.userData.originalPositions = geo.attributes.position.clone();
                const targetPos = new Float32Array(geo.attributes.position.count * 3);
                for (let i = 0; i < geo.attributes.position.count; i++) {
                    const p = new THREE.Vector3().fromBufferAttribute(geo.attributes.position, i);
                    const cubeP = getCubePosition(p).multiplyScalar(5 + Math.random() * 5);
                    targetPos[i*3] = cubeP.x;
                    targetPos[i*3+1] = cubeP.y;
                    targetPos[i*3+2] = cubeP.z;
                }
                mesh.userData.targetPositions = new THREE.BufferAttribute(targetPos, 3);
                nodeMaterials[node.id] = mat;
                return mesh;
            });
            
            // Custom edge as tube with shader
            edgeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(themes[currentThemeIndex].edgeColor) },
                    opacity: { value: 0.8 },
                    energy: { value: 0.0 }
                },
                vertexShader: document.getElementById('edgeVertexShader').textContent,
                fragmentShader: document.getElementById('edgeFragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            graph.linkThreeObjectExtended(true)
                .linkPositionUpdate((sprite, { start, end }) => {
                    const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                    sprite.position.copy(mid);
                    const dir = new THREE.Vector3().subVectors(end, start).normalize();
                    sprite.scale.z = start.distanceTo(end);
                    sprite.lookAt(end);
                    return true;
                })
                .linkThreeObject(link => {
                    const cylinder = new THREE.Mesh(
                        new THREE.CylinderGeometry(1, 1, 1, 8, 1, false),
                        edgeMaterial.clone() // Clone for per-link if needed
                    );
                    cylinder.scale.set(1, 1, 1); // Adjusted in positionUpdate
                    return cylinder;
                });
            
            // Labels if enabled
            graph.linkLabel(link => edgeLabelsVisible ? `${link.source.name} -> ${link.target.name}` : '');
            
            updateGraphData();
        }
        
        function getCubePosition(p) {
            const v = p.clone().normalize();
            const max = Math.max(Math.abs(v.x), Math.abs(v.y), Math.abs(v.z));
            return v.divideScalar(max);
        }
        
        function updateGraphData() {
            if (!disconnectedCheckbox.checked) {
                // Filter out disconnected nodes
                const connectedNodes = new Set();
                graphData.links.forEach(link => {
                    connectedNodes.add(link.source);
                    connectedNodes.add(link.target);
                });
                filteredGraphData.nodes = graphData.nodes.filter(node => connectedNodes.has(node.id));
                filteredGraphData.links = graphData.links;
            } else {
                filteredGraphData = {...graphData};
            }
            graph.graphData(filteredGraphData);
        }
        
        function applyTheme(index) {
            const theme = themes[index];
            themeButton.querySelector('span:last-of-type').textContent = `Theme: ${theme.name}`;
            ambientLight.color.set(theme.ambientLightColor);
            pointLight.color.set(theme.pointLightColor);
            dirLight1.color.set(theme.dirLight1);
            dirLight2.color.set(theme.dirLight2);
            edgeMaterial.uniforms.color.value.set(theme.edgeColor);
            // Update node materials
            filteredGraphData.nodes.forEach(node => {
                const mat = nodeMaterials[node.id];
                if (mat) {
                    mat.uniforms.baseColor.value.set(...theme.nodeColors[node.type]);
                    mat.uniforms.accentColor.value.set(...theme.accentColors[node.type]);
                }
            });
        }
        
        function toggleTheme() {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(currentThemeIndex);
        }
        
        function toggleMorph() {
            const morphEffect = {
                startTime: clock.getElapsedTime(),
                duration: 2.0,
                update: (elapsed) => {
                    let progress = elapsed / this.duration;
                    if (progress > 1) progress = 1;
                    const eased = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                    const morphProg = isMorphed ? 1 - eased : eased;
                    scene.traverse(obj => {
                        if (obj.userData.node) {
                            const geo = obj.geometry;
                            const orig = obj.userData.originalPositions;
                            const targ = obj.userData.targetPositions;
                            const pos = geo.attributes.position;
                            for (let i = 0; i < orig.count; i++) {
                                pos.setX(i, THREE.MathUtils.lerp(orig.getX(i), targ.getX(i), morphProg));
                                pos.setY(i, THREE.MathUtils.lerp(orig.getY(i), targ.getY(i), morphProg));
                                pos.setZ(i, THREE.MathUtils.lerp(orig.getZ(i), targ.getZ(i), morphProg));
                            }
                            pos.needsUpdate = true;
                            geo.computeVertexNormals();
                        }
                    });
                },
                end: () => {
                    isMorphed = !isMorphed;
                }
            };
            activeEffects.push(morphEffect);
        }
        
        function setLayout(layout) {
            currentLayout = layout;
            let dagMode = null;
            if (layout === 'layered') dagMode = 'td'; // top-down
            else if (layout === 'radial') dagMode = 'radialout';
            graph.dagMode(dagMode).graphData(filteredGraphData);
        }
        
        function activateGraph() {
            // Simulate activation: randomly select a link and pulse it
            const randomLink = filteredGraphData.links[Math.floor(Math.random() * filteredGraphData.links.length)];
            if (randomLink) {
                createPulse(randomLink.source, randomLink.target);
                // Update stats placeholder
                statsDiv.children[0].textContent = `Active: ${parseInt(statsDiv.children[0].textContent.split(': ')[1]) + 1}`;
                statsDiv.children[1].textContent = `Starts: ${parseInt(statsDiv.children[1].textContent.split(': ')[1]) + 1}`;
            }
        }
        
        function createPulse(sourceNode, targetNode) {
            const arcMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(0xff0000) },
                    opacity: { value: 0.0 },
                    energy: { value: 0.0 }
                },
                vertexShader: document.getElementById('edgeVertexShader').textContent,
                fragmentShader: document.getElementById('edgeFragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            const effect = {
                startTime: clock.getElapsedTime(),
                duration: 3.0,
                mesh: null,
                update: (elapsed) => {
                    const progress = elapsed / this.duration;
                    if (progress > 1) return;
                    const start = new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z);
                    const end = new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z);
                    const mid = start.clone().lerp(end, 0.5);
                    const control = mid.clone().add(new THREE.Vector3(0, start.distanceTo(end) * 0.3, 0));
                    const curve = new THREE.QuadraticBezierCurve3(start, control, end);
                    const geo = new THREE.TubeGeometry(curve, 64, 2, 8, false);
                    if (!this.mesh) {
                        this.mesh = new THREE.Mesh(geo, arcMaterial);
                        scene.add(this.mesh);
                    } else {
                        this.mesh.geometry.dispose();
                        this.mesh.geometry = geo;
                    }
                    const intensity = Math.sin(progress * Math.PI);
                    arcMaterial.uniforms.opacity.value = intensity;
                    arcMaterial.uniforms.energy.value = intensity * 2;
                    arcMaterial.uniforms.time.value += clock.getDelta();
                },
                end: () => {
                    if (this.mesh) {
                        scene.remove(this.mesh);
                        this.mesh.geometry.dispose();
                        arcMaterial.dispose();
                    }
                }
            };
            activeEffects.push(effect);
        }
        
        function refreshGraph() {
            graph.graphData(filteredGraphData);
        }
        
        function loadSnapshot() {
            // Placeholder: load new data
            alert('Load Snapshot functionality not implemented.');
        }
        
        function toggleEdgeLabels() {
            edgeLabelsVisible = !edgeLabelsVisible;
            edgeLabelsButton.querySelector('span:last-of-type').textContent = `Edge Labels: ${edgeLabelsVisible ? 'On' : 'Off'}`;
            graph.linkLabel(edgeLabelsVisible ? link => `${link.source.name} -> ${link.target.name}` : '');
        }
        
        function toggleDebugLog() {
            // Placeholder
            alert('Debug Log functionality not implemented.');
        }
        
        function toggleDisconnected() {
            updateGraphData();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            graph.tickFrame();
            
            // Update node shaders
            scene.traverse(obj => {
                if (obj.userData.node && obj.material.uniforms) {
                    obj.material.uniforms.time.value = time;
                }
            });
            edgeMaterial.uniforms.time.value = time;
            
            activeEffects.forEach((effect, i) => {
                const elapsed = time - effect.startTime;
                if (elapsed > effect.duration) {
                    effect.end();
                    activeEffects.splice(i, 1);
                } else {
                    effect.update(elapsed);
                }
            });
            
            controls.update();
            composer.render();
        }
        
        init();
        animate();
    </script>
</body>
</html>