<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stunning Graph Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;500;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
       
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #0a0f1a 0%, #020408 100%);
            height: 100vh;
            width: 100vw;
            font-family: 'Inter', 'Orbitron', sans-serif;
        }
       
        #container {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
       
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.01);
            backdrop-filter: blur(40px) saturate(180%);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.02),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
       
        .control-button {
            position: relative;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            padding: 10px 18px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            user-select: none;
            letter-spacing: 0.5px;
            text-transform: none;
            min-width: 100px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-shrink: 0;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 2px rgba(0, 0, 0, 0.24),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .control-button:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow:
                0 12px 36px rgba(0, 0, 0, 0.2),
                0 1px 3px rgba(0,0,0,0.24),
                inset 0 1px 0 rgba(255,255,255,0.15),
                inset 0 -1px 0 rgba(0,0,0,0.1);
        }
       
        .control-button:active {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(0);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 2px rgba(0, 0, 0, 0.24),
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        .control-button > span:last-of-type {
            position: relative;
            z-index: 2;
        }
        .control-button > span:not(:last-of-type) {
            position: absolute;
            display: block;
            box-shadow: 0 0 15px rgba(128, 200, 255, 0.9), 0 0 30px rgba(128, 200, 255, 0.7);
        }
        .control-button > span:nth-child(1) {
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(1) {
            animation: animateBorder1 2s linear infinite;
        }
        .control-button > span:nth-child(2) {
            top: -100%;
            right: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(2) {
            animation: animateBorder2 2s linear infinite;
            animation-delay: 0.5s;
        }
        .control-button > span:nth-child(3) {
            bottom: 0;
            right: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(270deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(3) {
            animation: animateBorder3 2s linear infinite;
            animation-delay: 1s;
        }
        .control-button > span:nth-child(4) {
            bottom: -100%;
            left: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(0deg, transparent, rgba(128, 200, 255, 1));
        }
        .control-button:hover > span:nth-child(4) {
            animation: animateBorder4 2s linear infinite;
            animation-delay: 1.5s;
        }
        @keyframes animateBorder1 { 0% { left: -100%; } 50%, 100% { left: 100%; } }
        @keyframes animateBorder2 { 0% { top: -100%; } 50%, 100% { top: 100%; } }
        @keyframes animateBorder3 { 0% { right: -100%; } 50%, 100% { right: 100%; } }
        @keyframes animateBorder4 { 0% { bottom: -100%; } 50%, 100% { bottom: 100%; } }
        .activate-button {
            background: linear-gradient(135deg,
                rgba(255, 100, 100, 0.15) 0%,
                rgba(255, 50, 50, 0.1) 100%);
            border: 1px solid rgba(255, 100, 100, 0.3);
            color: rgba(255, 150, 150, 0.95);
        }
       
        .activate-button:hover {
            background: linear-gradient(135deg,
                rgba(255, 120, 120, 0.2) 0%,
                rgba(255, 80, 80, 0.15) 100%);
            border-color: rgba(255, 150, 150, 0.4);
            color: rgba(255, 200, 200, 1);
        }
       
        .activate-button > span:not(:last-of-type) {
            box-shadow: 0 0 15px rgba(255, 120, 120, 0.9), 0 0 30px rgba(255, 120, 120, 0.7);
        }
        .activate-button > span:nth-child(1) { background: linear-gradient(90deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(2) { background: linear-gradient(180deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(3) { background: linear-gradient(270deg, transparent, rgba(255, 120, 120, 1)); }
        .activate-button > span:nth-child(4) { background: linear-gradient(0deg, transparent, rgba(255, 120, 120, 1)); }
       
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            line-height: 1.6;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px) saturate(150%);
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
       
        .stats div {
            margin-bottom: 4px;
            padding: 2px 0;
        }
       
        .stats div:last-child {
            margin-bottom: 0;
        }
       
        .control-button .icon {
            width: 16px;
            height: 16px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
       
        .control-button:hover .icon {
            opacity: 1;
        }
       
        .controls::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg,
                rgba(255, 255, 255, 0.05) 0%,
                transparent 25%,
                transparent 75%,
                rgba(255, 255, 255, 0.05) 100%);
            border-radius: 21px;
            z-index: -1;
            opacity: 0.5;
        }
        @media (max-width: 768px) {
             .controls {
                 gap: 8px;
                 bottom: 15px;
                 left: 15px;
                 right: 15px;
                 transform: translateX(0);
                 width: auto;
                 flex-direction: column;
             }
            .control-button {
                 padding: 10px 14px;
                 font-size: 11px;
                 flex-grow: 1;
                 width: 100%;
             }
            .stats {
                 top: 15px;
                 right: 15px;
                 padding: 8px 12px;
             }
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            cursor: pointer;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        /* Temporarily hide 3D container while using layered layout */
        #container { display: none; }
        #cy {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1;
        }
        .debug-panel {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 220px;
            overflow: auto;
            color: rgba(255,255,255,0.85);
            font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.35);
            border-top: 1px solid rgba(255,255,255,0.08);
            z-index: 6;
            padding: 8px 10px;
        }
        .debug-panel.hidden { display: none; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="stats" id="stats">
        <div>Active: 0</div>
        <div>Starts: 0</div>
        <div>Completes: 0</div>
        <div>Unmatched starts: 0</div>
    </div>
    <div class="controls">
        <button class="control-button" id="refresh">
            <span></span><span></span><span></span><span></span>
            <span>Refresh</span>
        </button>
        <button class="control-button" id="loadSnapshot">
            <span></span><span></span><span></span><span></span>
            <span>Load Snapshot</span>
        </button>
        <button class="control-button" id="edgeLabels">
            <span></span><span></span><span></span><span></span>
            <span>Edge Labels: Off</span>
        </button>
        <button class="control-button" id="debugLog">
            <span></span><span></span><span></span><span></span>
            <span>Debug Log</span>
        </button>
        <button class="control-button" id="layoutForce">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Force</span>
        </button>
        <button class="control-button" id="layoutLayered">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Layered</span>
        </button>
        <button class="control-button" id="layoutRadial">
            <span></span><span></span><span></span><span></span>
            <span>Layout: Radial</span>
        </button>
        <label class="checkbox-label" for="disconnected">
            <input type="checkbox" id="disconnected" checked>
            Disconnected
        </label>
        <button class="control-button activate-button" id="activateTrigger">
            <span></span><span></span><span></span><span></span>
            <span>Activate Graph</span>
        </button>
        <button class="control-button" id="toggleTheme">
            <span></span><span></span><span></span><span></span>
            <span>Theme: Inferno</span>
        </button>
        <button class="control-button" id="morphButton">
            <span></span><span></span><span></span><span></span>
            <span>Morph Shape</span>
        </button>
    </div>
    <div id="cy"></div>
    <div id="debugPanel" class="debug-panel hidden"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/layout-base@2.0.2/layout-base.min.js"></script>
    <script src="https://unpkg.com/cose-base@2.2.0/cose-base.min.js"></script>
    <script src="https://unpkg.com/cytoscape-fcose@2.2.0/cytoscape-fcose.min.js"></script>
    <script id="nodeVertexShader" type="x-shader/x-vertex">
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        void main() {
            vPosition = position;
            vNormal = normal;
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="nodeFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 baseColor;
        uniform vec3 accentColor;
        uniform float energy;
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        float noise(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
        void main() {
            vec2 uv = vUv + time * 0.02;
            float n1 = noise(uv * 8.0);
            float n2 = noise(uv * 16.0);
            float pattern = n1 * 0.7 + n2 * 0.3;
            vec3 color = mix(baseColor, accentColor, pattern);
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.5);
            color += fresnel * accentColor * 0.5;
            color *= (1.0 + energy * 0.8);
            gl_FragColor = vec4(color, 1.0);
        }
    </script>
    <script id="edgeVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="edgeFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 color;
        uniform float opacity;
        uniform float energy;
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            float flow = abs(sin(vUv.x * 15.0 - time * 12.0));
            float pulse = sin(time * 8.0) * 0.5 + 0.5;
            float pattern = pow(flow, 1.5) * (1.0 + pulse * energy);
            float fade = sin(vUv.x * 3.14159);
            vec3 finalColor = color * (pattern * 2.0 + 0.3);
            float alpha = fade * opacity * (pattern + 0.2) * (1.0 + energy);
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.161.0/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/",
            "three-forcegraph": "https://esm.sh/three-forcegraph@1.43.0?external=three"
        }
    }
    </script>
    <script type="module">
        // Layered graph (Cytoscape)
        const statsDiv = document.getElementById('stats');
        const debugPanel = document.getElementById('debugPanel');
        const refreshButton = document.getElementById('refresh');
        const loadSnapshotButton = document.getElementById('loadSnapshot');
        const debugLogButton = document.getElementById('debugLog');
        const layoutForceButton = document.getElementById('layoutForce');
        const layoutLayeredButton = document.getElementById('layoutLayered');
        const layoutRadialButton = document.getElementById('layoutRadial');
        const disconnectedCheckbox = document.getElementById('disconnected');
        const cy = cytoscape({
            container: document.getElementById('cy'),
            style: [
                { selector: 'node', style: { 'label': 'data(label)', 'font-size': 10, 'color': '#eee', 'text-background-opacity': 0.3, 'text-background-color': '#000', 'text-background-padding': 2, 'background-color': '#4491ff', 'border-width': 1, 'border-color': '#222' } },
                { selector: 'edge', style: { 'curve-style': 'bezier', 'line-color': '#ddd', 'width': 2, 'target-arrow-shape': 'triangle', 'target-arrow-color': '#ddd' } }
            ]
        });
        const __verbose = new URLSearchParams(location.search).has('trace');
        const activeByCall = new Map();
        let totalStarts = 0, totalCompletes = 0;
        function tsStr(){ const d = new Date(); return d.toTimeString().slice(0,8); }
        function appendDebugLine(text){
            const panel = document.getElementById('debugPanel');
            if (!panel) return;
            const div = document.createElement('div');
            div.textContent = text;
            panel.appendChild(div);
            while (panel.childElementCount > 500) panel.removeChild(panel.firstElementChild);
            panel.scrollTop = panel.scrollHeight;
        }
        function updateMetrics(){
            let active = 0; activeByCall.forEach(v => { if (v>0) active += v; });
            const unmatched = Array.from(activeByCall.values()).reduce((a,b)=> a + (b>0?b:0), 0);
            statsDiv.children[0].textContent = `Active: ${active}`;
            statsDiv.children[1].textContent = `Starts: ${totalStarts}`;
            statsDiv.children[2].textContent = `Completes: ${totalCompletes}`;
            statsDiv.children[3].textContent = `Unmatched starts: ${unmatched}`;
        }
        function levelForType(t){ if (t==='INTERFACE') return 0; if (t==='PRIMARY_AGENT'||t==='AGENT_PRIMARY'||t==='SPECIALIZED_AGENT') return 1; if (t==='SERVICE') return 2; return 3; }
        function hashId(id){ let h=0; for(let i=0;i<id.length;i++){ h=(h*31 + id.charCodeAt(i))>>>0; } return h; }
        function runLayeredPreset(){
            const container = cy.container();
            const w = container.clientWidth || window.innerWidth || 1200;
            const h = container.clientHeight || window.innerHeight || 800;
            const topPad = 80, bottomPad = 80; const usableH = Math.max(h - topPad - bottomPad, 200);
            const bands = 4; const bandGap = usableH / (bands - 1);
            const jitterY = 24; const agentJitterY = 45; const agentStaggerAmp = Math.min(60, bandGap * 0.18);
            const interfaces = cy.nodes().filter(n=>n.data('type')==='INTERFACE');
            const agents = cy.nodes().filter(n=>['PRIMARY_AGENT','AGENT_PRIMARY','SPECIALIZED_AGENT'].includes(n.data('type')));
            const services = cy.nodes().filter(n=>n.data('type')==='SERVICE');
            const functions = cy.nodes().filter(n=>!['INTERFACE','PRIMARY_AGENT','AGENT_PRIMARY','SPECIALIZED_AGENT','SERVICE'].includes(n.data('type')));
            function spreadHoriz(collection, yBase, customJitter){ const arr = collection.sort((a,b)=> hashId(a.id()) - hashId(b.id())).toArray(); const count = Math.max(arr.length, 1); const xStep = w / (count + 1); arr.forEach((n, i)=>{ const jitter = ((hashId(n.id()) % 200)/200 - 0.5) * 2 * (customJitter ?? jitterY); n.position({ x: (i+1)*xStep, y: yBase + jitter }); }); }
            spreadHoriz(interfaces, topPad + 0*bandGap, jitterY);
            (function placeAgents(){ const yBase = topPad + 1*bandGap; const arr = agents.sort((a,b)=> hashId(a.id()) - hashId(b.id())).toArray(); const count = Math.max(arr.length, 1); const xStep = w / (count + 1); const mid = (count - 1) / 2; arr.forEach((n, i)=>{ const norm = count === 1 ? 0 : (i - mid) / mid; const stagger = agentStaggerAmp * norm; const jitter = ((hashId(n.id()) % 200)/200 - 0.5) * 2 * agentJitterY; n.position({ x: (i+1)*xStep, y: yBase + stagger + jitter }); }); })();
            spreadHoriz(services, topPad + 2*bandGap, jitterY);
            const serviceX = new Map(); services.forEach(s=> serviceX.set(s.id(), s.position('x')));
            const svcToFuncs = new Map(); services.forEach(s => { const fnNodes = s.outgoers('edge').targets().filter(n => n.data('type') === 'FUNCTION'); if (fnNodes.nonempty()) svcToFuncs.set(s.id(), fnNodes.map(n => n.id())); });
            const placedFuncs = new Set(); const funcY = topPad + 3*bandGap; const clusterSpacing = 60;
            services.forEach(s=>{ const sid = s.id(); const fx = serviceX.get(sid); const ids = (svcToFuncs.get(sid) || []).slice(); const count = ids.length; if (count === 0) return; ids.sort((a,b)=>{ const la = (cy.$(`#${a}`).data('label')||'').toString(); const lb = (cy.$(`#${b}`).data('label')||'').toString(); return la.localeCompare(lb); }); const width = (count - 1) * clusterSpacing; ids.forEach((fid, idx)=>{ const fNode = cy.$(`#${fid}`); if (fNode.empty()) return; const jitter = ((hashId(fid) % 200)/200 - 0.5) * 2 * jitterY; fNode.position({ x: fx - width/2 + idx*clusterSpacing, y: funcY + jitter }); placedFuncs.add(fid); }); });
            const remaining = functions.filter(n=> !placedFuncs.has(n.id())); if (remaining.nonempty()) spreadHoriz(remaining, funcY, jitterY);
            cy.layout({ name: 'preset', fit: true }).run(); cy.fit(cy.elements(), 40); cy.resize();
        }
        function runLayout(mode){ if (mode === 'layered') runLayeredPreset(); else if (mode === 'radial'){ cy.layout({ name: 'concentric', concentric: n => 10 - levelForType(n.data('type')), levelWidth: () => 1, minNodeSpacing: 50, startAngle: Math.PI/2, sweep: Math.PI*2, padding: 50, animate: false, fit: true }).run(); cy.fit(cy.elements(), 40); cy.resize(); } else { const opts = window.__hasFcose ? { name: 'fcose', quality: 'default', randomize: true, idealEdgeLength: 120, nodeSeparation: 60, nodeRepulsion: 4500, edgeElasticity: 0.25, gravity: 0.8, animate: false, fit: true } : { name: 'cose', idealEdgeLength: 120, nodeRepulsion: 8000, nodeOverlap: 10, refresh: 20, gravity: 1, animate: false, fit: true }; cy.layout(opts).run(); cy.fit(cy.elements(), 40); cy.resize(); } }
        function applyElements(elements) {
            cy.startBatch();
            cy.elements().remove();
            if (elements && Array.isArray(elements.nodes)) cy.add(elements.nodes);
            if (elements && Array.isArray(elements.edges)) cy.add(elements.edges);
            cy.endBatch();
            appendDebugLine(`[${tsStr()}] applyElements nodes=${cy.nodes().length} edges=${cy.edges().length}`);
            runLayout('layered');
        }
        function fetchGraph(source='live') { const url = source === 'snapshot' ? '/api/graph?source=snapshot' : '/api/graph'; return fetch(url).then(r => r.json()); }
        function refreshSnapshot() {
            appendDebugLine(`[${tsStr()}] refresh live graph`);
            fetchGraph('live').then(data => {
                const nodes = data?.elements?.nodes?.length || 0;
                const edges = data?.elements?.edges?.length || 0;
                appendDebugLine(`[${tsStr()}] /api/graph live nodes=${nodes} edges=${edges}`);
                if (nodes === 0 && edges === 0) return fetchGraph('snapshot');
                return data;
            }).then(data => { if (data) applyElements(data.elements || {nodes: [], edges: []}); }).catch(e => { console.error(e); appendDebugLine(`[${tsStr()}] ERROR ${e}`); });
        }
        function setDebugVisible(v){ debugPanel.classList.toggle('hidden', !v); document.getElementById('cy').style.bottom = v ? (debugPanel.offsetHeight || 180) + 'px' : '0'; cy.resize(); }
        refreshButton.onclick = refreshSnapshot;
        loadSnapshotButton.onclick = () => fetchGraph('snapshot').then(data => applyElements(data.elements || {nodes: [], edges: []}));
        debugLogButton.onclick = () => setDebugVisible(debugPanel.classList.contains('hidden'));
        layoutForceButton.onclick = () => runLayout('force');
        layoutLayeredButton.onclick = () => runLayout('layered');
        layoutRadialButton.onclick = () => runLayout('radial');
        disconnectedCheckbox.onchange = refreshSnapshot;
        const ioUrl = `${window.location.protocol}//${window.location.host}`;
        const socket = window.io(ioUrl, { transports: ['websocket', 'polling'] });
        socket.on('connect', () => { socket.emit('graph_snapshot'); });
        socket.on('graph_snapshot', (data) => {
            const n = data?.elements?.nodes?.length || 0; const e = data?.elements?.edges?.length || 0;
            appendDebugLine(`[${tsStr()}] socket graph_snapshot nodes=${n} edges=${e}`);
            applyElements(data.elements);
        });
        socket.on('node_update', (payload) => {
            const n = payload.node || payload; const id = n.component_id || n.node_id || n.id; const type = n.component_type || n.node_type; const state = n.state || n.node_state; const label = (n.attrs && (n.attrs.prefered_name || n.attrs.service_name || n.attrs.function_name)) || n.node_name || id; if (!id) return;
            const existed = !cy.$id(id).empty();
            if (!existed) { cy.add({ group: 'nodes', data: { id, label, type, state } }); appendDebugLine(`[${tsStr()}] node_add id=${id} type=${type||''} label="${label||''}"`); }
            else { cy.$id(id).data({ label, type, state }); appendDebugLine(`[${tsStr()}] node_update id=${id} type=${type||''} label="${label||''}"`); }
            runLayout('layered');
        });
        socket.on('edge_update', (payload) => {
            const e = payload.edge || payload; const sid = e.source_id || e.source; const tid = e.target_id || e.target; const et = e.edge_type || e.type; if (!sid || !tid) return; const id = `${sid}->${tid}:${et || ''}`;
            if (cy.$id(id).empty()) { cy.add({ group: 'edges', data: { id, source: sid, target: tid, type: et } }); appendDebugLine(`[${tsStr()}] edge_add ${sid} -> ${tid} type=${et||''}`); }
            runLayout('layered');
        });
        socket.on('activity', (act) => {
            const sid = act.source_id || ''; const tid = act.target_id || ''; const ev = String(act.event_type||'');
            const isStart = ev.endsWith('_START'); const isComplete = ev.endsWith('_COMPLETE') || ev.endsWith('RECEIVED');
            const callId = act.call_id || `${sid}->${tid}:${ev}:${act.timestamp}`;
            if (__verbose) appendDebugLine(`[${tsStr()}] activity ${ev} ${sid} -> ${tid} call=${(callId||'').toString().slice(0,8)}`);
            if (isStart) { totalStarts++; activeByCall.set(callId, (activeByCall.get(callId)||0) + 1); }
            if (isComplete) { const cur = activeByCall.get(callId)||0; totalCompletes++; activeByCall.set(callId, Math.max(0, cur-1)); }
            updateMetrics();
        });
        refreshSnapshot();
        
        let ambientLight, pointLight, dirLight1, dirLight2;
        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0x1a2440, 0.8);
            scene.add(ambientLight);
            
            pointLight = new THREE.PointLight(0xffe4b5, 3, 500);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
            
            dirLight1 = new THREE.DirectionalLight(0x4488ff, 0.5);
            dirLight1.position.set(-200, 100, -100);
            scene.add(dirLight1);
            
            dirLight2 = new THREE.DirectionalLight(0x8844ff, 0.3);
            dirLight2.position.set(100, -50, 200);
            scene.add(dirLight2);
        }
        
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.1);
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());
        }
        
        function createEnvironment() {
            // Similar to example, add starfield layers
            const layers = [
                { count: 5000, distance: [200, 500], size: [0.5, 1.0], color: 0x6688bb },
                { count: 3000, distance: [500, 1000], size: [0.8, 1.5], color: 0x88aadd },
                { count: 2000, distance: [1000, 2000], size: [1.0, 2.0], color: 0xaaccff }
            ];
            layers.forEach(layer => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(layer.count * 3);
                const colors = new Float32Array(layer.count * 3);
                const sizes = new Float32Array(layer.count);
                const color = new THREE.Color(layer.color);
                for (let i = 0; i < layer.count; i++) {
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = layer.distance[0] + Math.random() * (layer.distance[1] - layer.distance[0]);
                    positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i*3+2] = r * Math.cos(phi);
                    colors[i*3] = color.r;
                    colors[i*3+1] = color.g;
                    colors[i*3+2] = color.b;
                    sizes[i] = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                const material = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.7
                });
                const starfield = new THREE.Points(geometry, material);
                scene.add(starfield);
            });
        }
        
        let nodeMaterials = {};
        let edgeMaterial;
        function setupGraph() {
            graph = new ForceGraph3D({
                extraRenderers: [] // If needed for custom
            });
            scene.add(graph);
            
            // Custom node object
            graph.nodeThreeObject(node => {
                const geo = new THREE.IcosahedronGeometry(5 + Math.random() * 5, 3); // Size based on something
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        baseColor: { value: new THREE.Vector3(...themes[currentThemeIndex].nodeColors[node.type]) },
                        accentColor: { value: new THREE.Vector3(...themes[currentThemeIndex].accentColors[node.type]) },
                        energy: { value: 0.0 }
                    },
                    vertexShader: document.getElementById('nodeVertexShader').textContent,
                    fragmentShader: document.getElementById('nodeFragmentShader').textContent
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.userData.node = node;
                mesh.userData.originalPositions = geo.attributes.position.clone();
                const targetPos = new Float32Array(geo.attributes.position.count * 3);
                for (let i = 0; i < geo.attributes.position.count; i++) {
                    const p = new THREE.Vector3().fromBufferAttribute(geo.attributes.position, i);
                    const cubeP = getCubePosition(p).multiplyScalar(5 + Math.random() * 5);
                    targetPos[i*3] = cubeP.x;
                    targetPos[i*3+1] = cubeP.y;
                    targetPos[i*3+2] = cubeP.z;
                }
                mesh.userData.targetPositions = new THREE.BufferAttribute(targetPos, 3);
                nodeMaterials[node.id] = mat;
                return mesh;
            });
            
            // Custom edge as tube with shader
            edgeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(themes[currentThemeIndex].edgeColor) },
                    opacity: { value: 0.8 },
                    energy: { value: 0.0 }
                },
                vertexShader: document.getElementById('edgeVertexShader').textContent,
                fragmentShader: document.getElementById('edgeFragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const edgeGeom = new THREE.CylinderGeometry(1, 1, 1, 8, 1, false);
            edgeGeom.rotateX(Math.PI / 2);
            graph.linkThreeObjectExtend(true)
                .linkThreeObject(link => {
                    const group = new THREE.Group();
                    const cylinder = new THREE.Mesh(edgeGeom.clone(), edgeMaterial.clone());
                    cylinder.name = 'edgeCylinder';
                    group.add(cylinder);
                    const labelText = `${(link.source?.name || link.source?.id || '')} -> ${(link.target?.name || link.target?.id || '')}`;
                    const label = createTextSprite(labelText);
                    label.name = 'edgeLabel';
                    label.visible = edgeLabelsVisible;
                    label.position.set(0, 2, 0);
                    group.add(label);
                    return group;
                })
                .linkPositionUpdate((obj, { start, end }) => {
                    const mid = new THREE.Vector3(
                        (start.x + end.x) / 2,
                        (start.y + end.y) / 2,
                        (start.z + end.z) / 2
                    );
                    obj.position.copy(mid);
                    obj.lookAt(new THREE.Vector3(end.x, end.y, end.z));
                    const cylinder = obj.getObjectByName('edgeCylinder');
                    if (cylinder) {
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        const dz = end.z - start.z;
                        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        cylinder.scale.set(1, 1, distance);
                    }
                    return true;
                });
            
            // Removed linkLabel (not available in three-forcegraph); labels handled via sprites
            
            updateGraphData();
        }
        
        function getCubePosition(p) {
            const v = p.clone().normalize();
            const max = Math.max(Math.abs(v.x), Math.abs(v.y), Math.abs(v.z));
            return v.divideScalar(max);
        }
        
        function createTextSprite(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 64;
            const padding = 16;
            ctx.font = `${fontSize}px Inter, Arial, sans-serif`;
            const metrics = ctx.measureText(text);
            canvas.width = Math.ceil(metrics.width + padding * 2);
            canvas.height = Math.ceil(fontSize + padding * 2);
            ctx.font = `${fontSize}px Inter, Arial, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.textBaseline = 'top';
            ctx.fillText(text, padding, padding);
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
            const sprite = new THREE.Sprite(material);
            const scaleFactor = 0.05;
            sprite.scale.set(canvas.width * scaleFactor, canvas.height * scaleFactor, 1);
            sprite.userData.isLinkLabel = true;
            return sprite;
        }
        
        function updateGraphData() {
            if (!disconnectedCheckbox.checked) {
                // Filter out disconnected nodes
                const connectedNodes = new Set();
                graphData.links.forEach(link => {
                    connectedNodes.add(link.source);
                    connectedNodes.add(link.target);
                });
                filteredGraphData.nodes = graphData.nodes.filter(node => connectedNodes.has(node.id));
                filteredGraphData.links = graphData.links;
            } else {
                filteredGraphData = {...graphData};
            }
            graph.graphData(filteredGraphData);
        }
        
        function applyTheme(index) {
            const theme = themes[index];
            themeButton.querySelector('span:last-of-type').textContent = `Theme: ${theme.name}`;
            ambientLight.color.set(theme.ambientLightColor);
            pointLight.color.set(theme.pointLightColor);
            dirLight1.color.set(theme.dirLight1);
            dirLight2.color.set(theme.dirLight2);
            edgeMaterial.uniforms.color.value.set(theme.edgeColor);
            // Update node materials
            filteredGraphData.nodes.forEach(node => {
                const mat = nodeMaterials[node.id];
                if (mat) {
                    mat.uniforms.baseColor.value.set(...theme.nodeColors[node.type]);
                    mat.uniforms.accentColor.value.set(...theme.accentColors[node.type]);
                }
            });
        }
        
        function toggleTheme() {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(currentThemeIndex);
        }
        
        function toggleMorph() {
            const morphEffect = {
                startTime: clock.getElapsedTime(),
                duration: 2.0,
                update: (elapsed) => {
                    let progress = elapsed / this.duration;
                    if (progress > 1) progress = 1;
                    const eased = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                    const morphProg = isMorphed ? 1 - eased : eased;
                    scene.traverse(obj => {
                        if (obj.userData.node) {
                            const geo = obj.geometry;
                            const orig = obj.userData.originalPositions;
                            const targ = obj.userData.targetPositions;
                            const pos = geo.attributes.position;
                            for (let i = 0; i < orig.count; i++) {
                                pos.setX(i, THREE.MathUtils.lerp(orig.getX(i), targ.getX(i), morphProg));
                                pos.setY(i, THREE.MathUtils.lerp(orig.getY(i), targ.getY(i), morphProg));
                                pos.setZ(i, THREE.MathUtils.lerp(orig.getZ(i), targ.getZ(i), morphProg));
                            }
                            pos.needsUpdate = true;
                            geo.computeVertexNormals();
                        }
                    });
                },
                end: () => {
                    isMorphed = !isMorphed;
                }
            };
            activeEffects.push(morphEffect);
        }
        
        function setLayout(layout) {
            currentLayout = layout;
            let dagMode = null;
            if (layout === 'layered') dagMode = 'td'; // top-down
            else if (layout === 'radial') dagMode = 'radialout';
            if (typeof graph.dagMode === 'function') {
                graph.dagMode(dagMode).graphData(filteredGraphData);
            } else {
                graph.graphData(filteredGraphData);
            }
        }
        
        function activateGraph() {
            // Simulate activation: randomly select a link and pulse it
            const randomLink = filteredGraphData.links[Math.floor(Math.random() * filteredGraphData.links.length)];
            if (randomLink) {
                createPulse(randomLink.source, randomLink.target);
                // Update stats placeholder
                statsDiv.children[0].textContent = `Active: ${parseInt(statsDiv.children[0].textContent.split(': ')[1]) + 1}`;
                statsDiv.children[1].textContent = `Starts: ${parseInt(statsDiv.children[1].textContent.split(': ')[1]) + 1}`;
            }
        }
        
        function createPulse(sourceNode, targetNode) {
            const arcMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(0xff0000) },
                    opacity: { value: 0.0 },
                    energy: { value: 0.0 }
                },
                vertexShader: document.getElementById('edgeVertexShader').textContent,
                fragmentShader: document.getElementById('edgeFragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            const effect = {
                startTime: clock.getElapsedTime(),
                duration: 3.0,
                mesh: null,
                update: (elapsed) => {
                    const progress = elapsed / this.duration;
                    if (progress > 1) return;
                    const start = new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z);
                    const end = new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z);
                    const mid = start.clone().lerp(end, 0.5);
                    const control = mid.clone().add(new THREE.Vector3(0, start.distanceTo(end) * 0.3, 0));
                    const curve = new THREE.QuadraticBezierCurve3(start, control, end);
                    const geo = new THREE.TubeGeometry(curve, 64, 2, 8, false);
                    if (!this.mesh) {
                        this.mesh = new THREE.Mesh(geo, arcMaterial);
                        scene.add(this.mesh);
                    } else {
                        this.mesh.geometry.dispose();
                        this.mesh.geometry = geo;
                    }
                    const intensity = Math.sin(progress * Math.PI);
                    arcMaterial.uniforms.opacity.value = intensity;
                    arcMaterial.uniforms.energy.value = intensity * 2;
                    arcMaterial.uniforms.time.value += clock.getDelta();
                },
                end: () => {
                    if (this.mesh) {
                        scene.remove(this.mesh);
                        this.mesh.geometry.dispose();
                        arcMaterial.dispose();
                    }
                }
            };
            activeEffects.push(effect);
        }
        
        function refreshGraph() {
            graph.graphData(filteredGraphData);
        }
        
        function loadSnapshot() {
            // Placeholder: load new data
            alert('Load Snapshot functionality not implemented.');
        }
        
        function toggleEdgeLabels() {
            edgeLabelsVisible = !edgeLabelsVisible;
            edgeLabelsButton.querySelector('span:last-of-type').textContent = `Edge Labels: ${edgeLabelsVisible ? 'On' : 'Off'}`;
            scene.traverse(obj => {
                if (obj.name === 'edgeLabel' || (obj.userData && obj.userData.isLinkLabel)) {
                    obj.visible = edgeLabelsVisible;
                }
            });
        }
        
        function toggleDebugLog() {
            // Placeholder
            alert('Debug Log functionality not implemented.');
        }
        
        function toggleDisconnected() {
            updateGraphData();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            graph.tickFrame();
            
            // Update node shaders
            scene.traverse(obj => {
                if (obj.userData.node && obj.material && obj.material.uniforms && obj.material.uniforms.time) {
                    obj.material.uniforms.time.value = time;
                }
                if (obj.material && obj.material.uniforms && obj.material.uniforms.time) {
                    obj.material.uniforms.time.value = time;
                }
            });
            
            // edgeMaterial is cloned per link, so update all clones via traversal above
            
            activeEffects.forEach((effect, i) => {
                const elapsed = time - effect.startTime;
                if (elapsed > effect.duration) {
                    effect.end();
                    activeEffects.splice(i, 1);
                } else {
                    effect.update(elapsed);
                }
            });
            
            controls.update();
            composer.render();
        }
        
        // Using layered (Cytoscape) graph; 3D init disabled
        try { refreshSnapshot(); } catch(e) { /* no-op */ }
    </script>
</body>
</html>